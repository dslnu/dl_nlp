<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.43">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Tutorial 11 (JAX): Normalizing Flows for image modeling – Deep Learning/NLP course</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script><script src="../../../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../../../../">
<script src="../../../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../../../site_libs/quarto-html/quarto-syntax-highlighting-d4d76bf8491c20bad77d141916dc28e1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../../../site_libs/bootstrap/bootstrap-6bd9cfa162949bde0a231f530c97869d.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>
<script src="https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js" crossorigin="anonymous"></script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../../../../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../../../../index.html">
    <span class="navbar-title">Deep Learning/NLP course</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../../../../dl.html"> 
<span class="menu-text">Deep Learning</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../../../../nlp.html"> 
<span class="menu-text">Natural Language Processing</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../../../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#normalizing-flows-as-generative-model" id="toc-normalizing-flows-as-generative-model" class="nav-link active" data-scroll-target="#normalizing-flows-as-generative-model">Normalizing Flows as generative model</a></li>
  <li><a href="#normalizing-flows-on-images" id="toc-normalizing-flows-on-images" class="nav-link" data-scroll-target="#normalizing-flows-on-images">Normalizing Flows on images</a>
  <ul class="collapse">
  <li><a href="#dequantization" id="toc-dequantization" class="nav-link" data-scroll-target="#dequantization">Dequantization</a></li>
  <li><a href="#variational-dequantization" id="toc-variational-dequantization" class="nav-link" data-scroll-target="#variational-dequantization">Variational Dequantization</a></li>
  <li><a href="#coupling-layers" id="toc-coupling-layers" class="nav-link" data-scroll-target="#coupling-layers">Coupling layers</a></li>
  <li><a href="#training-loop" id="toc-training-loop" class="nav-link" data-scroll-target="#training-loop">Training loop</a></li>
  </ul></li>
  <li><a href="#multi-scale-architecture" id="toc-multi-scale-architecture" class="nav-link" data-scroll-target="#multi-scale-architecture">Multi-scale architecture</a>
  <ul class="collapse">
  <li><a href="#squeeze-and-split" id="toc-squeeze-and-split" class="nav-link" data-scroll-target="#squeeze-and-split">Squeeze and Split</a></li>
  <li><a href="#building-a-multi-scale-flow" id="toc-building-a-multi-scale-flow" class="nav-link" data-scroll-target="#building-a-multi-scale-flow">Building a multi-scale flow</a></li>
  </ul></li>
  <li><a href="#analysing-the-flows" id="toc-analysing-the-flows" class="nav-link" data-scroll-target="#analysing-the-flows">Analysing the flows</a>
  <ul class="collapse">
  <li><a href="#training-flow-variants" id="toc-training-flow-variants" class="nav-link" data-scroll-target="#training-flow-variants">Training flow variants</a></li>
  <li><a href="#density-modeling-and-sampling" id="toc-density-modeling-and-sampling" class="nav-link" data-scroll-target="#density-modeling-and-sampling">Density modeling and sampling</a></li>
  <li><a href="#interpolation-in-latent-space" id="toc-interpolation-in-latent-space" class="nav-link" data-scroll-target="#interpolation-in-latent-space">Interpolation in latent space</a></li>
  <li><a href="#visualization-of-latents-in-different-levels-of-multi-scale" id="toc-visualization-of-latents-in-different-levels-of-multi-scale" class="nav-link" data-scroll-target="#visualization-of-latents-in-different-levels-of-multi-scale">Visualization of latents in different levels of multi-scale</a></li>
  <li><a href="#visualizing-dequantization" id="toc-visualizing-dequantization" class="nav-link" data-scroll-target="#visualizing-dequantization">Visualizing Dequantization</a></li>
  </ul></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Tutorial 11 (JAX): Normalizing Flows for image modeling</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://img.shields.io/static/v1.svg?label=Status&amp;message=Finished&amp;color=green" class="img-fluid figure-img"></p>
<figcaption>Status</figcaption>
</figure>
</div>
<p><strong>Filled notebook:</strong> <a href="https://github.com/phlippe/uvadlc_notebooks/blob/master/docs/tutorial_notebooks/JAX/tutorial11/NF_image_modeling.ipynb"><img src="https://img.shields.io/static/v1.svg?logo=github&amp;label=Repo&amp;message=View%20On%20Github&amp;color=lightgrey" class="img-fluid" alt="View notebook on Github"></a> <a href="https://colab.research.google.com/github/phlippe/uvadlc_notebooks/blob/master/docs/tutorial_notebooks/JAX/tutorial11/NF_image_modeling.ipynb"><img src="https://colab.research.google.com/assets/colab-badge.svg" class="img-fluid" alt="Open In Collab"></a><br>
<strong>Pre-trained models:</strong> <a href="https://github.com/phlippe/saved_models/tree/main/JAX/tutorial11"><img src="https://img.shields.io/static/v1.svg?logo=github&amp;label=Repo&amp;message=View%20On%20Github&amp;color=lightgrey" class="img-fluid" alt="View files on Github"></a><br>
<strong>PyTorch version:</strong> <a href="https://uvadlc-notebooks.readthedocs.io/en/latest/tutorial_notebooks/tutorial11/NF_image_modeling.html"><img src="https://img.shields.io/static/v1.svg?logo=readthedocs&amp;label=RTD&amp;message=View%20On%20RTD&amp;color=8CA1AF" class="img-fluid" alt="View on RTD"></a><br>
<strong>Author:</strong> Phillip Lippe</p>
<div class="alert alert-info">
<p><strong>Note:</strong> This notebook is written in JAX+Flax. It is a 1-to-1 translation of the original notebook written in PyTorch+PyTorch Lightning with almost identical results. For an introduction to JAX, check out our <a href="https://uvadlc-notebooks.readthedocs.io/en/latest/tutorial_notebooks/JAX/tutorial2/Introduction_to_JAX.html">Tutorial 2 (JAX): Introduction to JAX+Flax</a>. Further, throughout the notebook, we comment on major differences to the PyTorch version and provide explanations for the major parts of the JAX code.</p>
</div>
<hr>
<p><strong>Speed comparison</strong>: We note the training times for all models in the PyTorch and the JAX implementation below (PyTorch v1.11, JAX v0.3.13). The models were trained on the same hardware (NVIDIA RTX3090, 24 core CPU) and we slightly adjusted the tutorials to use the exact same training settings (200 epochs, data loading parameters, evaluation schedule, etc.). Overall, the JAX implementation is <em>2.0-2.5x faster</em> than PyTorch! Different network architectures may have different speedups.</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Models</th>
<th style="text-align: center;">PyTorch</th>
<th style="text-align: center;">JAX</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>MNIST Flow - Simple</td>
<td style="text-align: center;">2hrs 37min 29sec</td>
<td style="text-align: center;">1hrs 17min 59sec</td>
</tr>
<tr class="even">
<td>MNIST Flow - VarDeq</td>
<td style="text-align: center;">3hrs 25min 10sec</td>
<td style="text-align: center;">1hrs 36min 56sec</td>
</tr>
<tr class="odd">
<td>MNIST Flow - Multiscale</td>
<td style="text-align: center;">2hrs 17min 10sec</td>
<td style="text-align: center;">57min 57sec</td>
</tr>
</tbody>
</table>
<hr>
<p>In this tutorial, we will take a closer look at complex, deep normalizing flows. The most popular, current application of deep normalizing flows is to model datasets of images. As for other generative models, images are a good domain to start working on because (1) CNNs are widely studied and strong models exist, (2) images are high-dimensional and complex, and (3) images are discrete integers. In this tutorial, we will review current advances in normalizing flows for image modeling, and get hands-on experience on coding normalizing flows. Note that normalizing flows are commonly parameter heavy and therefore computationally expensive. We will use relatively simple and shallow flows to save computational cost and allow you to run the notebook on CPU, but keep in mind that a simple way to improve the scores of the flows we study here is to make them deeper. The first cell imports our usual libraries.</p>
<div id="cell-5" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">## Standard libraries</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> time</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> json</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> typing <span class="im">import</span> Sequence</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co">## Imports for plotting</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>matplotlib inline </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> IPython.display <span class="im">import</span> set_matplotlib_formats</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>set_matplotlib_formats(<span class="st">'svg'</span>, <span class="st">'pdf'</span>) <span class="co"># For export</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib.colors <span class="im">import</span> to_rgb</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>matplotlib.rcParams[<span class="st">'lines.linewidth'</span>] <span class="op">=</span> <span class="fl">2.0</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>sns.reset_orig()</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="co">## Progress bar</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tqdm.notebook <span class="im">import</span> tqdm</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a><span class="co">## To run JAX on TPU in Google Colab, uncomment the two lines below</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a><span class="co"># import jax.tools.colab_tpu</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span class="co"># jax.tools.colab_tpu.setup_tpu()</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a><span class="co">## JAX</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> jax</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> jax.numpy <span class="im">as</span> jnp</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> jax <span class="im">import</span> random</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a><span class="co"># Seeding for random operations</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>main_rng <span class="op">=</span> random.PRNGKey(<span class="dv">42</span>)</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a><span class="co">## Flax (NN in JAX)</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>:</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> flax</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a><span class="cf">except</span> <span class="pp">ModuleNotFoundError</span>: <span class="co"># Install flax if missing</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>    <span class="op">!</span>pip install <span class="op">--</span>quiet flax</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> flax</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> flax <span class="im">import</span> linen <span class="im">as</span> nn</span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> flax.training <span class="im">import</span> train_state, checkpoints</span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a><span class="co">## Optax (Optimizers in JAX)</span></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>:</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> optax</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a><span class="cf">except</span> <span class="pp">ModuleNotFoundError</span>: <span class="co"># Install optax if missing</span></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>    <span class="op">!</span>pip install <span class="op">--</span>quiet optax</span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> optax</span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a><span class="co">## PyTorch Data Loading</span></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch.utils.data <span class="im">as</span> data</span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> torch.utils.tensorboard <span class="im">import</span> SummaryWriter</span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torchvision</span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> torchvision.datasets <span class="im">import</span> MNIST</span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a><span class="co"># Path to the folder where the datasets are/should be downloaded (e.g. MNIST)</span></span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>DATASET_PATH <span class="op">=</span> <span class="st">"../../data"</span></span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a><span class="co"># Path to the folder where the pretrained models are saved</span></span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>CHECKPOINT_PATH <span class="op">=</span> <span class="st">"../../saved_models/tutorial11_jax"</span></span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Device:"</span>, jax.devices()[<span class="dv">0</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>/home/phillip/anaconda3/envs/dl2020/lib/python3.7/site-packages/chex/_src/pytypes.py:37: FutureWarning: jax.tree_structure is deprecated, and will be removed in a future release. Use jax.tree_util.tree_structure instead.
  PyTreeDef = type(jax.tree_structure(None))
WARNING:absl:GlobalAsyncCheckpointManager is not imported correctly. Checkpointing of GlobalDeviceArrays will not be available.To use the feature, install tensorstore.</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Device: gpu:0</code></pre>
</div>
</div>
<p>Again, we have a few pretrained models. We download them below to the specified path above.</p>
<div id="cell-7" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> urllib.request</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> urllib.error <span class="im">import</span> HTTPError</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Github URL where saved models are stored for this tutorial</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>base_url <span class="op">=</span> <span class="st">"https://raw.githubusercontent.com/phlippe/saved_models/main/JAX/tutorial11/"</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Files to download</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>pretrained_files <span class="op">=</span> [<span class="st">"MNISTFlow_simple.ckpt"</span>, <span class="st">"MNISTFlow_vardeq.ckpt"</span>, <span class="st">"MNISTFlow_multiscale.ckpt"</span>,</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>                    <span class="st">"MNISTFlow_simple_results.json"</span>, <span class="st">"MNISTFlow_vardeq_results.json"</span>, <span class="st">"MNISTFlow_multiscale_results.json"</span>]</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Create checkpoint path if it doesn't exist yet</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>os.makedirs(CHECKPOINT_PATH, exist_ok<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="co"># For each file, check whether it already exists. If not, try downloading it.</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> file_name <span class="kw">in</span> pretrained_files:</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    file_path <span class="op">=</span> os.path.join(CHECKPOINT_PATH, file_name)</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> os.path.isfile(file_path):</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>        file_url <span class="op">=</span> base_url <span class="op">+</span> file_name</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Downloading </span><span class="sc">{</span>file_url<span class="sc">}</span><span class="ss">..."</span>)</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span>:</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>            urllib.request.urlretrieve(file_url, file_path)</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">except</span> HTTPError <span class="im">as</span> e:</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="st">"Something went wrong. Please contact the author with the full output including the following error:</span><span class="ch">\n</span><span class="st">"</span>, e)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We will use the MNIST dataset in this notebook. MNIST constitutes, despite its simplicity, a challenge for small generative models as it requires the global understanding of an image. At the same time, we can easily judge whether generated images come from the same distribution as the dataset (i.e.&nbsp;represent real digits), or not.</p>
<p>To deal better with the discrete nature of the images, we transform them from a range of 0-1 to a range of 0-255 as integers.</p>
<div id="cell-9" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Transformations applied on each image =&gt; bring them into a numpy array</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Note that we keep them in the range 0-255 (integers)</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> image_to_numpy(img):</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    img <span class="op">=</span> np.array(img, dtype<span class="op">=</span>np.int32)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    img <span class="op">=</span> img[...,<span class="va">None</span>]  <span class="co"># Make image [28, 28, 1]</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> img</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="co"># We need to stack the batch elements</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> numpy_collate(batch):</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">isinstance</span>(batch[<span class="dv">0</span>], np.ndarray):</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.stack(batch)</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> <span class="bu">isinstance</span>(batch[<span class="dv">0</span>], (<span class="bu">tuple</span>,<span class="bu">list</span>)):</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>        transposed <span class="op">=</span> <span class="bu">zip</span>(<span class="op">*</span>batch)</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> [numpy_collate(samples) <span class="cf">for</span> samples <span class="kw">in</span> transposed]</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.array(batch)</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Loading the training dataset. We need to split it into a training and validation part</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>train_dataset <span class="op">=</span> MNIST(root<span class="op">=</span>DATASET_PATH, train<span class="op">=</span><span class="va">True</span>, transform<span class="op">=</span>image_to_numpy, download<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>train_set, val_set <span class="op">=</span> torch.utils.data.random_split(train_dataset, [<span class="dv">50000</span>, <span class="dv">10000</span>], </span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>                                                   generator<span class="op">=</span>torch.Generator().manual_seed(<span class="dv">42</span>))</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Loading the test set</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>test_set <span class="op">=</span> MNIST(root<span class="op">=</span>DATASET_PATH, train<span class="op">=</span><span class="va">False</span>, transform<span class="op">=</span>image_to_numpy, download<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a><span class="co"># We define a set of data loaders that we can use for various purposes</span></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a><span class="co"># Data loader for loading examples throughout the notebook</span></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>train_exmp_loader <span class="op">=</span> data.DataLoader(train_set, batch_size<span class="op">=</span><span class="dv">256</span>, shuffle<span class="op">=</span><span class="va">False</span>, drop_last<span class="op">=</span><span class="va">False</span>, collate_fn<span class="op">=</span>numpy_collate)</span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a><span class="co"># Actual data loaders for training, validation, and testing</span></span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>train_data_loader <span class="op">=</span> data.DataLoader(train_set,</span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a>                                    batch_size<span class="op">=</span><span class="dv">128</span>,</span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>                                    shuffle<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a>                                    drop_last<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a>                                    collate_fn<span class="op">=</span>numpy_collate,</span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a>                                    num_workers<span class="op">=</span><span class="dv">8</span>,</span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a>                                    persistent_workers<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a>val_loader <span class="op">=</span> data.DataLoader(val_set, batch_size<span class="op">=</span><span class="dv">64</span>, shuffle<span class="op">=</span><span class="va">False</span>, drop_last<span class="op">=</span><span class="va">False</span>, num_workers<span class="op">=</span><span class="dv">4</span>, collate_fn<span class="op">=</span>numpy_collate)</span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a>test_loader <span class="op">=</span> data.DataLoader(test_set, batch_size<span class="op">=</span><span class="dv">64</span>, shuffle<span class="op">=</span><span class="va">False</span>, drop_last<span class="op">=</span><span class="va">False</span>, num_workers<span class="op">=</span><span class="dv">4</span>, collate_fn<span class="op">=</span>numpy_collate)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>In addition, we will define below a function to simplify the visualization of images/samples. Some training examples of the MNIST dataset is shown below.</p>
<div id="cell-11" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> show_imgs(imgs, title<span class="op">=</span><span class="va">None</span>, row_size<span class="op">=</span><span class="dv">4</span>):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Form a grid of pictures (we use max. 8 columns)</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    imgs <span class="op">=</span> np.copy(jax.device_get(imgs))</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    num_imgs <span class="op">=</span> imgs.shape[<span class="dv">0</span>]</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    is_int <span class="op">=</span> (imgs.dtype<span class="op">==</span>np.int32)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    nrow <span class="op">=</span> <span class="bu">min</span>(num_imgs, row_size)</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    ncol <span class="op">=</span> <span class="bu">int</span>(math.ceil(num_imgs<span class="op">/</span>nrow))</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    imgs_torch <span class="op">=</span> torch.from_numpy(imgs).permute(<span class="dv">0</span>, <span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">2</span>)</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    imgs <span class="op">=</span> torchvision.utils.make_grid(imgs_torch, nrow<span class="op">=</span>nrow, pad_value<span class="op">=</span><span class="dv">128</span> <span class="cf">if</span> is_int <span class="cf">else</span> <span class="fl">0.5</span>)</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    np_imgs <span class="op">=</span> imgs.cpu().numpy()</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot the grid</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    plt.figure(figsize<span class="op">=</span>(<span class="fl">1.5</span><span class="op">*</span>nrow, <span class="fl">1.5</span><span class="op">*</span>ncol))</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    plt.imshow(np.transpose(np_imgs, (<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">0</span>)), interpolation<span class="op">=</span><span class="st">'nearest'</span>)</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    plt.axis(<span class="st">'off'</span>)</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> title <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>        plt.title(title)</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>    plt.show()</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    plt.close()</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>show_imgs(np.stack([train_set[i][<span class="dv">0</span>] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">8</span>)], axis<span class="op">=</span><span class="dv">0</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="NF_image_modeling_files/figure-html/cell-5-output-1.svg" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<section id="normalizing-flows-as-generative-model" class="level2">
<h2 class="anchored" data-anchor-id="normalizing-flows-as-generative-model">Normalizing Flows as generative model</h2>
<p>In the previous lectures, we have seen Energy-based models, Variational Autoencoders (VAEs) and Generative Adversarial Networks (GANs) as example of generative models. However, none of them explicitly learn the probability density function <span class="math inline">\(p(x)\)</span> of the real input data. While VAEs model a lower bound, energy-based models only implicitly learn the probability density. GANs on the other hand provide us a sampling mechanism for generating new data, without offering a likelihood estimate. The generative model we will look at here, called Normalizing Flows, actually models the true data distribution <span class="math inline">\(p(x)\)</span> and provides us with an exact likelihood estimate. Below, we can visually compare VAEs, GANs and Flows (figure credit - <a href="https://lilianweng.github.io/lil-log/2018/10/13/flow-based-deep-generative-models.html">Lilian Weng</a>):</p>
<center width="100%">
<img src="../../tutorial11/comparison_GAN_VAE_NF.png" width="600px">
</center>
<p>The major difference compared to VAEs is that flows use <em>invertible</em> functions <span class="math inline">\(f\)</span> to map the input data <span class="math inline">\(x\)</span> to a latent representation <span class="math inline">\(z\)</span>. To realize this, <span class="math inline">\(z\)</span> must be of the same shape as <span class="math inline">\(x\)</span>. This is in contrast to VAEs where <span class="math inline">\(z\)</span> is usually much lower dimensional than the original input data. However, an invertible mapping also means that for every data point <span class="math inline">\(x\)</span>, we have a corresponding latent representation <span class="math inline">\(z\)</span> which allows us to perform lossless reconstruction (<span class="math inline">\(z\)</span> to <span class="math inline">\(x\)</span>). In the visualization above, this means that <span class="math inline">\(x=x'\)</span> for flows, no matter what invertible function <span class="math inline">\(f\)</span> and input <span class="math inline">\(x\)</span> we choose.</p>
<p>Nonetheless, how are normalizing flows modeling a probability density with an invertible function? The answer to this question is the rule for change of variables. Specifically, given a prior density <span class="math inline">\(p_z(z)\)</span> (e.g.&nbsp;Gaussian) and an invertible function <span class="math inline">\(f\)</span>, we can determine <span class="math inline">\(p_x(x)\)</span> as follows:</p>
<p><span class="math display">\[
\begin{split}
    \int p_x(x) dx &amp; = \int p_z(z) dz = 1 \hspace{1cm}\text{(by definition of a probability distribution)}\\
    \Leftrightarrow p_x(x) &amp; = p_z(z) \left|\frac{dz}{dx}\right| = p_z(f(x)) \left|\frac{df(x)}{dx}\right|
\end{split}
\]</span></p>
<p>Hence, in order to determine the probability of <span class="math inline">\(x\)</span>, we only need to determine its probability in latent space, and get the derivate of <span class="math inline">\(f\)</span>. Note that this is for a univariate distribution, and <span class="math inline">\(f\)</span> is required to be invertible and smooth. For a multivariate case, the derivative becomes a Jacobian of which we need to take the determinant. As we usually use the log-likelihood as objective, we write the multivariate term with logarithms below:</p>
<p><span class="math display">\[
\log p_x(\mathbf{x}) = \log p_z(f(\mathbf{x})) + \log{} \left|\det \frac{df(\mathbf{x})}{d\mathbf{x}}\right|
\]</span></p>
<p>Although we now know how a normalizing flow obtains its likelihood, it might not be clear what a normalizing flow does intuitively. For this, we should look from the inverse perspective of the flow starting with the prior probability density <span class="math inline">\(p_z(z)\)</span>. If we apply an invertible function on it, we effectively “transform” its probability density. For instance, if <span class="math inline">\(f^{-1}(z)=z+1\)</span>, we shift the density by one while still remaining a valid probability distribution, and being invertible. We can also apply more complex transformations, like scaling: <span class="math inline">\(f^{-1}(z)=2z+1\)</span>, but there you might see a difference. When you scale, you also change the volume of the probability density, as for example on uniform distributions (figure credit - <a href="https://blog.evjang.com/2018/01/nf1.html">Eric Jang</a>):</p>
<center width="100%">
<img src="../../tutorial11/uniform_flow.png" width="300px">
</center>
<p>You can see that the height of <span class="math inline">\(p(y)\)</span> should be lower than <span class="math inline">\(p(x)\)</span> after scaling. This change in volume represents <span class="math inline">\(\left|\frac{df(x)}{dx}\right|\)</span> in our equation above, and ensures that even after scaling, we still have a valid probability distribution. We can go on with making our function <span class="math inline">\(f\)</span> more complex. However, the more complex <span class="math inline">\(f\)</span> becomes, the harder it will be to find the inverse <span class="math inline">\(f^{-1}\)</span> of it, and to calculate the log-determinant of the Jacobian <span class="math inline">\(\log{} \left|\det \frac{df(\mathbf{x})}{d\mathbf{x}}\right|\)</span> (often abbreviated as <em>LDJ</em>). An easier trick to stack multiple invertible functions <span class="math inline">\(f_{1,...,K}\)</span> after each other, as all together, they still represent a single, invertible function. Using multiple, learnable invertible functions, a normalizing flow attempts to transform <span class="math inline">\(p_z(z)\)</span> slowly into a more complex distribution which should finally be <span class="math inline">\(p_x(x)\)</span>. We visualize the idea below (figure credit - <a href="https://lilianweng.github.io/lil-log/2018/10/13/flow-based-deep-generative-models.html">Lilian Weng</a>):</p>
<center width="100%">
<img src="../../tutorial11/normalizing_flow_layout.png" width="700px">
</center>
<p>Starting from <span class="math inline">\(z_0\)</span>, which follows the prior Gaussian distribution, we sequentially apply the invertible functions <span class="math inline">\(f_1,f_2,...,f_K\)</span>, until <span class="math inline">\(z_K\)</span> represents <span class="math inline">\(x\)</span>. Note that in the figure above, the functions <span class="math inline">\(f\)</span> represent the inverted function from <span class="math inline">\(f\)</span> we had above (here: <span class="math inline">\(f:Z\to X\)</span>, above: <span class="math inline">\(f:X\to Z\)</span>). This is just a different notation and has no impact on the actual flow design because all <span class="math inline">\(f\)</span> need to be invertible anyways. When we estimate the log likelihood of a data point <span class="math inline">\(x\)</span> as in the equations above, we run the flows in the opposite direction than visualized above. Multiple flow layers have been proposed that use a neural network as learnable parameters, such as the planar and radial flow. However, we will focus here on flows that are commonly used in image modeling, and will discuss them in the rest of the notebook along with the details of how to train a normalizing flow.</p>
</section>
<section id="normalizing-flows-on-images" class="level2">
<h2 class="anchored" data-anchor-id="normalizing-flows-on-images">Normalizing Flows on images</h2>
<p>To become familiar with normalizing flows, especially for the application of image modeling, it is best to discuss the different elements in a flow along with the implementation. As a general concept, we want to build a normalizing flow that maps an input image (here MNIST) to an equally sized latent space:</p>
<center width="100%" style="padding: 10px">
<img src="../../tutorial11/image_to_gaussian.svg" width="450px">
</center>
<p>As a first step, we will implement a template of a normalizing flow. During training and validation, a normalizing flow performs density estimation in the forward direction. For this, we apply a series of flow transformations on the input <span class="math inline">\(x\)</span> and estimate the probability of the input by determining the probability of the transformed point <span class="math inline">\(z\)</span> given a prior, and the change of volume caused by the transformations. During inference, we can do both density estimation and sampling new points by inverting the flow transformations. Therefore, we define a function <code>_get_likelihood</code> which performs density estimation, and <code>sample</code> to generate new examples.</p>
<p>The standard metric used in generative models, and in particular normalizing flows, is bits per dimensions (bpd). Bpd is motivated from an information theory perspective and describes how many bits we would need to encode a particular example in our modeled distribution. The less bits we need, the more likely the example in our distribution. When we test for the bits per dimension of our test dataset, we can judge whether our model generalizes to new samples of the dataset and didn’t memorize the training dataset. In order to calculate the bits per dimension score, we can rely on the negative log-likelihood and change the log base (as bits are binary while NLL is usually exponential):</p>
<p><span class="math display">\[\text{bpd} = \text{nll} \cdot \log_2\left(\exp(1)\right) \cdot \left(\prod d_i\right)^{-1}\]</span></p>
<p>where <span class="math inline">\(d_1,...,d_K\)</span> are the dimensions of the input. For images, this would be the height, width and channel number. We divide the log likelihood by these extra dimensions to have a metric which we can compare for different image resolutions. In the original image space, MNIST examples have a bits per dimension score of 8 (we need 8 bits to encode each pixel as there are 256 possible values).</p>
<div id="cell-14" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ImageFlow(nn.Module):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    flows : Sequence[nn.Module]  <span class="co"># A list of flows (each a nn.Module) that should be applied on the images. </span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    import_samples : <span class="bu">int</span> <span class="op">=</span> <span class="dv">8</span>  <span class="co"># Number of importance samples to use during testing (see explanation below).</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__call__</span>(<span class="va">self</span>, x, rng, testing<span class="op">=</span><span class="va">False</span>):</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> testing:</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>            bpd, rng <span class="op">=</span> <span class="va">self</span>._get_likelihood(x, rng)</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Perform importance sampling during testing =&gt; estimate likelihood M times for each image</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>            img_ll, rng <span class="op">=</span> <span class="va">self</span>._get_likelihood(x.repeat(<span class="va">self</span>.import_samples, <span class="dv">0</span>), </span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>                                               rng,</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>                                               return_ll<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>            img_ll <span class="op">=</span> img_ll.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="va">self</span>.import_samples)</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>            <span class="co"># To average the probabilities, we need to go from log-space to exp, and back to log.</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Logsumexp provides us a stable implementation for this</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>            img_ll <span class="op">=</span> jax.nn.logsumexp(img_ll, axis<span class="op">=-</span><span class="dv">1</span>) <span class="op">-</span> np.log(<span class="va">self</span>.import_samples)</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Calculate final bpd</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>            bpd <span class="op">=</span> <span class="op">-</span>img_ll <span class="op">*</span> np.log2(np.exp(<span class="dv">1</span>)) <span class="op">/</span> np.prod(x.shape[<span class="dv">1</span>:])</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>            bpd <span class="op">=</span> bpd.mean()</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> bpd, rng</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> encode(<span class="va">self</span>, imgs, rng):</span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Given a batch of images, return the latent representation z and </span></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>        <span class="co"># log-determinant jacobian (ldj) of the transformations</span></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>        z, ldj <span class="op">=</span> imgs, jnp.zeros(imgs.shape[<span class="dv">0</span>])</span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> flow <span class="kw">in</span> <span class="va">self</span>.flows:</span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a>            z, ldj, rng <span class="op">=</span> flow(z, ldj, rng, reverse<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> z, ldj, rng</span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _get_likelihood(<span class="va">self</span>, imgs, rng, return_ll<span class="op">=</span><span class="va">False</span>):</span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a><span class="co">        Given a batch of images, return the likelihood of those. </span></span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a><span class="co">        If return_ll is True, this function returns the log likelihood of the input.</span></span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true" tabindex="-1"></a><span class="co">        Otherwise, the ouptut metric is bits per dimension (scaled negative log likelihood)</span></span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb7-38"><a href="#cb7-38" aria-hidden="true" tabindex="-1"></a>        z, ldj, rng <span class="op">=</span> <span class="va">self</span>.encode(imgs, rng)</span>
<span id="cb7-39"><a href="#cb7-39" aria-hidden="true" tabindex="-1"></a>        log_pz <span class="op">=</span> jax.scipy.stats.norm.logpdf(z).<span class="bu">sum</span>(axis<span class="op">=</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>))</span>
<span id="cb7-40"><a href="#cb7-40" aria-hidden="true" tabindex="-1"></a>        log_px <span class="op">=</span> ldj <span class="op">+</span> log_pz</span>
<span id="cb7-41"><a href="#cb7-41" aria-hidden="true" tabindex="-1"></a>        nll <span class="op">=</span> <span class="op">-</span>log_px</span>
<span id="cb7-42"><a href="#cb7-42" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Calculating bits per dimension</span></span>
<span id="cb7-43"><a href="#cb7-43" aria-hidden="true" tabindex="-1"></a>        bpd <span class="op">=</span> nll <span class="op">*</span> np.log2(np.exp(<span class="dv">1</span>)) <span class="op">/</span> np.prod(imgs.shape[<span class="dv">1</span>:])</span>
<span id="cb7-44"><a href="#cb7-44" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (bpd.mean() <span class="cf">if</span> <span class="kw">not</span> return_ll <span class="cf">else</span> log_px), rng</span>
<span id="cb7-45"><a href="#cb7-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-46"><a href="#cb7-46" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> sample(<span class="va">self</span>, img_shape, rng, z_init<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb7-47"><a href="#cb7-47" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb7-48"><a href="#cb7-48" aria-hidden="true" tabindex="-1"></a><span class="co">        Sample a batch of images from the flow.</span></span>
<span id="cb7-49"><a href="#cb7-49" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb7-50"><a href="#cb7-50" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Sample latent representation from prior</span></span>
<span id="cb7-51"><a href="#cb7-51" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> z_init <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb7-52"><a href="#cb7-52" aria-hidden="true" tabindex="-1"></a>            rng, normal_rng <span class="op">=</span> random.split(rng)</span>
<span id="cb7-53"><a href="#cb7-53" aria-hidden="true" tabindex="-1"></a>            z <span class="op">=</span> random.normal(normal_rng, shape<span class="op">=</span>img_shape)</span>
<span id="cb7-54"><a href="#cb7-54" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb7-55"><a href="#cb7-55" aria-hidden="true" tabindex="-1"></a>            z <span class="op">=</span> z_init</span>
<span id="cb7-56"><a href="#cb7-56" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-57"><a href="#cb7-57" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Transform z to x by inverting the flows</span></span>
<span id="cb7-58"><a href="#cb7-58" aria-hidden="true" tabindex="-1"></a>        <span class="co"># The log-determinant jacobian (ldj) is usually not of interest during sampling</span></span>
<span id="cb7-59"><a href="#cb7-59" aria-hidden="true" tabindex="-1"></a>        ldj <span class="op">=</span> jnp.zeros(img_shape[<span class="dv">0</span>])</span>
<span id="cb7-60"><a href="#cb7-60" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> flow <span class="kw">in</span> <span class="bu">reversed</span>(<span class="va">self</span>.flows):</span>
<span id="cb7-61"><a href="#cb7-61" aria-hidden="true" tabindex="-1"></a>            z, ldj, rng <span class="op">=</span> flow(z, ldj, rng, reverse<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb7-62"><a href="#cb7-62" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> z, rng</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The test step differs from the training and validation step in that it makes use of importance sampling. We will discuss the motiviation and details behind this after understanding how flows model discrete images in continuous space.</p>
<section id="dequantization" class="level3">
<h3 class="anchored" data-anchor-id="dequantization">Dequantization</h3>
<p>Normalizing flows rely on the rule of change of variables, which is naturally defined in continuous space. Applying flows directly on discrete data leads to undesired density models where arbitrarily high likelihood are placed on a few, particular values. See the illustration below:</p>
<center>
<img src="../../tutorial11/dequantization_issue.svg" width="500px">
</center>
<p>The black points represent the discrete points, and the green volume the density modeled by a normalizing flow in continuous space. The flow would continue to increase the likelihood for <span class="math inline">\(x=0,1,2,3\)</span> while having no volume on any other point. Remember that in continuous space, we have the constraint that the overall volume of the probability density must be 1 (<span class="math inline">\(\int p(x)dx=1\)</span>). Otherwise, we don’t model a probability distribution anymore. However, the discrete points <span class="math inline">\(x=0,1,2,3\)</span> represent delta peaks with no width in continuous space. This is why the flow can place an infinite high likelihood on these few points while still representing a distribution in continuous space. Nonetheless, the learned density does not tell us anything about the distribution among the discrete points, as in discrete space, the likelihoods of those four points would have to sum to 1, not to infinity.</p>
<p>To prevent such degenerated solutions, a common solution is to add a small amount of noise to each discrete value, which is also referred to as dequantization. Considering <span class="math inline">\(x\)</span> as an integer (as it is the case for images), the dequantized representation <span class="math inline">\(v\)</span> can be formulated as <span class="math inline">\(v=x+u\)</span> where <span class="math inline">\(u\in[0,1)^D\)</span>. Thus, the discrete value <span class="math inline">\(1\)</span> is modeled by a distribution over the interval <span class="math inline">\([1.0, 2.0)\)</span>, the value <span class="math inline">\(2\)</span> by an volume over <span class="math inline">\([2.0, 3.0)\)</span>, etc. Our objective of modeling <span class="math inline">\(p(x)\)</span> becomes:</p>
<p><span class="math display">\[ p(x) = \int p(x+u)du = \int \frac{q(u|x)}{q(u|x)}p(x+u)du = \mathbb{E}_{u\sim q(u|x)}\left[\frac{p(x+u)}{q(u|x)} \right]\]</span></p>
<p>with <span class="math inline">\(q(u|x)\)</span> being the noise distribution. For now, we assume it to be uniform, which can also be written as <span class="math inline">\(p(x)=\mathbb{E}_{u\sim U(0,1)^D}\left[p(x+u) \right]\)</span>.</p>
<p>In the following, we will implement Dequantization as a flow transformation itself. After adding noise to the discrete values, we additionally transform the volume into a Gaussian-like shape. This is done by scaling <span class="math inline">\(x+u\)</span> between <span class="math inline">\(0\)</span> and <span class="math inline">\(1\)</span>, and applying the invert of the sigmoid function <span class="math inline">\(\sigma(z)^{-1} = \log z - \log 1-z\)</span>. If we would not do this, we would face two problems:</p>
<ol type="1">
<li>The input is scaled between 0 and 256 while the prior distribution is a Gaussian with mean <span class="math inline">\(0\)</span> and standard deviation <span class="math inline">\(1\)</span>. In the first iterations after initializing the parameters of the flow, we would have extremely low likelihoods for large values like <span class="math inline">\(256\)</span>. This would cause the training to diverge instantaneously.</li>
<li>As the output distribution is a Gaussian, it is beneficial for the flow to have a similarly shaped input distribution. This will reduce the modeling complexity that is required by the flow.</li>
</ol>
<p>Overall, we can implement dequantization as follows:</p>
<div id="cell-17" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Dequantization(nn.Module):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    alpha : <span class="bu">float</span> <span class="op">=</span> <span class="fl">1e-5</span>  <span class="co"># Small constant that is used to scale the original input for numerical stability.</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    quants : <span class="bu">int</span> <span class="op">=</span> <span class="dv">256</span>    <span class="co"># Number of possible discrete values (usually 256 for 8-bit image)</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__call__</span>(<span class="va">self</span>, z, ldj, rng, reverse<span class="op">=</span><span class="va">False</span>):</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> reverse:</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>            z, ldj, rng <span class="op">=</span> <span class="va">self</span>.dequant(z, ldj, rng)</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>            z, ldj <span class="op">=</span> <span class="va">self</span>.sigmoid(z, ldj, reverse<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>            z, ldj <span class="op">=</span> <span class="va">self</span>.sigmoid(z, ldj, reverse<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>            z <span class="op">=</span> z <span class="op">*</span> <span class="va">self</span>.quants</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>            ldj <span class="op">+=</span> np.log(<span class="va">self</span>.quants) <span class="op">*</span> np.prod(z.shape[<span class="dv">1</span>:])</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>            z <span class="op">=</span> jnp.floor(z)</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>            z <span class="op">=</span> jax.lax.clamp(<span class="bu">min</span><span class="op">=</span><span class="fl">0.</span>, x<span class="op">=</span>z, <span class="bu">max</span><span class="op">=</span><span class="va">self</span>.quants<span class="op">-</span><span class="fl">1.</span>).astype(jnp.int32)</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> z, ldj, rng</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> sigmoid(<span class="va">self</span>, z, ldj, reverse<span class="op">=</span><span class="va">False</span>):</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Applies an invertible sigmoid transformation</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> reverse:</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>            ldj <span class="op">+=</span> (<span class="op">-</span>z<span class="op">-</span><span class="dv">2</span><span class="op">*</span>jax.nn.softplus(<span class="op">-</span>z)).<span class="bu">sum</span>(axis<span class="op">=</span>[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>])</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>            z <span class="op">=</span> nn.sigmoid(z)</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Reversing scaling for numerical stability</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>            ldj <span class="op">-=</span> np.log(<span class="dv">1</span> <span class="op">-</span> <span class="va">self</span>.alpha) <span class="op">*</span> np.prod(z.shape[<span class="dv">1</span>:])</span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>            z <span class="op">=</span> (z <span class="op">-</span> <span class="fl">0.5</span> <span class="op">*</span> <span class="va">self</span>.alpha) <span class="op">/</span> (<span class="dv">1</span> <span class="op">-</span> <span class="va">self</span>.alpha)</span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>            z <span class="op">=</span> z <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> <span class="va">self</span>.alpha) <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> <span class="va">self</span>.alpha  <span class="co"># Scale to prevent boundaries 0 and 1</span></span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>            ldj <span class="op">+=</span> np.log(<span class="dv">1</span> <span class="op">-</span> <span class="va">self</span>.alpha) <span class="op">*</span> np.prod(z.shape[<span class="dv">1</span>:])</span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>            ldj <span class="op">+=</span> (<span class="op">-</span>jnp.log(z) <span class="op">-</span> jnp.log(<span class="dv">1</span><span class="op">-</span>z)).<span class="bu">sum</span>(axis<span class="op">=</span>[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>])</span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a>            z <span class="op">=</span> jnp.log(z) <span class="op">-</span> jnp.log(<span class="dv">1</span><span class="op">-</span>z)</span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> z, ldj</span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> dequant(<span class="va">self</span>, z, ldj, rng):</span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Transform discrete values to continuous volumes</span></span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a>        z <span class="op">=</span> z.astype(jnp.float32)</span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a>        rng, uniform_rng <span class="op">=</span> random.split(rng)</span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true" tabindex="-1"></a>        z <span class="op">=</span> z <span class="op">+</span> random.uniform(uniform_rng, z.shape)</span>
<span id="cb8-37"><a href="#cb8-37" aria-hidden="true" tabindex="-1"></a>        z <span class="op">=</span> z <span class="op">/</span> <span class="va">self</span>.quants</span>
<span id="cb8-38"><a href="#cb8-38" aria-hidden="true" tabindex="-1"></a>        ldj <span class="op">-=</span> np.log(<span class="va">self</span>.quants) <span class="op">*</span> np.prod(z.shape[<span class="dv">1</span>:])</span>
<span id="cb8-39"><a href="#cb8-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> z, ldj, rng</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>A good check whether a flow is correctly implemented or not, is to verify that it is invertible. Hence, we will dequantize a randomly chosen training image, and then quantize it again. We would expect that we would get the exact same image out:</p>
<div id="cell-19" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co">## Testing invertibility of dequantization layer</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>orig_img <span class="op">=</span> train_set[<span class="dv">0</span>][<span class="dv">0</span>][<span class="va">None</span>]  <span class="co"># Example image</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>ldj <span class="op">=</span> jnp.zeros(<span class="dv">1</span>,)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>dequant_module <span class="op">=</span> Dequantization()</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>dequant_rng <span class="op">=</span> random.PRNGKey(<span class="dv">5</span>)</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>deq_img, ldj, dequant_rng <span class="op">=</span> dequant_module(orig_img, ldj, dequant_rng, reverse<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>reconst_img, ldj, dequant_rng <span class="op">=</span> dequant_module(deq_img, ldj, dequant_rng, reverse<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>d1, d2 <span class="op">=</span> jnp.where(orig_img.squeeze() <span class="op">!=</span> reconst_img.squeeze())</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="bu">len</span>(d1) <span class="op">!=</span> <span class="dv">0</span>:</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Dequantization was not invertible."</span>)</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(d1.shape[<span class="dv">0</span>]):</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"Original value:"</span>, orig_img[<span class="dv">0</span>,d1[i],d2[i],<span class="dv">0</span>].item())</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"Reconstructed value:"</span>, reconst_img[<span class="dv">0</span>,d1[i],d2[i],<span class="dv">0</span>].item())</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Successfully inverted dequantization"</span>)</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Layer is not strictly invertible due to float precision constraints</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a><span class="co"># assert (orig_img == reconst_img).all().item()</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Successfully inverted dequantization</code></pre>
</div>
</div>
<p>The test succeeds as we would expect. However, there is a chance that the test fails due to numerical inaccuracies in the sigmoid invert. While the input space to the inverted sigmoid is scaled between 0 and 1, the output space is between <span class="math inline">\(-\infty\)</span> and <span class="math inline">\(\infty\)</span>. And as we use 32 bits to represent the numbers (in addition to applying logs over and over again), such inaccuries can occur and should not be worrisome. Nevertheless, it is good to be aware of them, and can be improved by using a double tensor (float64).</p>
<p>Finally, we can take our dequantization and actually visualize the distribution it transforms the discrete values into:</p>
<div id="cell-21" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> visualize_dequantization(quants, prior<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Function for visualizing the dequantization values of discrete values in continuous space</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Prior over discrete values. If not given, a uniform is assumed</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> prior <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>        prior <span class="op">=</span> np.ones(quants, dtype<span class="op">=</span>np.float32) <span class="op">/</span> quants</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    prior <span class="op">=</span> prior <span class="op">/</span> prior.<span class="bu">sum</span>()  <span class="co"># Ensure proper categorical distribution</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    inp <span class="op">=</span> jnp.arange(<span class="op">-</span><span class="dv">4</span>, <span class="dv">4</span>, <span class="fl">0.01</span>).reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>)  <span class="co"># Possible continuous values we want to consider</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    ldj <span class="op">=</span> jnp.zeros(inp.shape[<span class="dv">0</span>])</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    dequant_module <span class="op">=</span> Dequantization(quants<span class="op">=</span>quants)</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Invert dequantization on continuous values to find corresponding discrete value</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>    out, ldj, _ <span class="op">=</span> dequant_module(inp, ldj, rng<span class="op">=</span><span class="va">None</span>, reverse<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>    inp, out, prob <span class="op">=</span> inp.squeeze(), out.squeeze(), jnp.exp(ldj)</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>    prob <span class="op">=</span> prob <span class="op">*</span> prior[out] <span class="co"># Probability scaled by categorical prior</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot volumes and continuous distribution</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>    sns.set_style(<span class="st">"white"</span>)</span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>    fig <span class="op">=</span> plt.figure(figsize<span class="op">=</span>(<span class="dv">6</span>,<span class="dv">3</span>))</span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>    x_ticks <span class="op">=</span> []</span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v <span class="kw">in</span> np.unique(out):</span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>        indices <span class="op">=</span> np.where(out<span class="op">==</span>v)</span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> to_rgb(<span class="ss">f"C</span><span class="sc">{</span>v<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>        plt.fill_between(inp[indices], prob[indices], np.zeros(indices[<span class="dv">0</span>].shape[<span class="dv">0</span>]), color<span class="op">=</span>color<span class="op">+</span>(<span class="fl">0.5</span>,), label<span class="op">=</span><span class="bu">str</span>(v))</span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>        plt.plot([inp[indices[<span class="dv">0</span>][<span class="dv">0</span>]]]<span class="op">*</span><span class="dv">2</span>,  [<span class="dv">0</span>, prob[indices[<span class="dv">0</span>][<span class="dv">0</span>]]],  color<span class="op">=</span>color)</span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a>        plt.plot([inp[indices[<span class="dv">0</span>][<span class="op">-</span><span class="dv">1</span>]]]<span class="op">*</span><span class="dv">2</span>, [<span class="dv">0</span>, prob[indices[<span class="dv">0</span>][<span class="op">-</span><span class="dv">1</span>]]], color<span class="op">=</span>color)</span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>        x_ticks.append(inp[indices[<span class="dv">0</span>][<span class="dv">0</span>]])</span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a>    x_ticks.append(inp.<span class="bu">max</span>())</span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a>    plt.xticks(x_ticks, [<span class="ss">f"</span><span class="sc">{</span>x<span class="sc">:.1f}</span><span class="ss">"</span> <span class="cf">for</span> x <span class="kw">in</span> x_ticks])</span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a>    plt.plot(inp,prob, color<span class="op">=</span>(<span class="fl">0.0</span>,<span class="fl">0.0</span>,<span class="fl">0.0</span>))</span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Set final plot properties</span></span>
<span id="cb11-33"><a href="#cb11-33" aria-hidden="true" tabindex="-1"></a>    plt.ylim(<span class="dv">0</span>, prob.<span class="bu">max</span>()<span class="op">*</span><span class="fl">1.1</span>)</span>
<span id="cb11-34"><a href="#cb11-34" aria-hidden="true" tabindex="-1"></a>    plt.xlim(inp.<span class="bu">min</span>(), inp.<span class="bu">max</span>())</span>
<span id="cb11-35"><a href="#cb11-35" aria-hidden="true" tabindex="-1"></a>    plt.xlabel(<span class="st">"z"</span>)</span>
<span id="cb11-36"><a href="#cb11-36" aria-hidden="true" tabindex="-1"></a>    plt.ylabel(<span class="st">"Probability"</span>)</span>
<span id="cb11-37"><a href="#cb11-37" aria-hidden="true" tabindex="-1"></a>    plt.title(<span class="ss">f"Dequantization distribution for </span><span class="sc">{</span>quants<span class="sc">}</span><span class="ss"> discrete values"</span>)</span>
<span id="cb11-38"><a href="#cb11-38" aria-hidden="true" tabindex="-1"></a>    plt.legend()</span>
<span id="cb11-39"><a href="#cb11-39" aria-hidden="true" tabindex="-1"></a>    plt.show()</span>
<span id="cb11-40"><a href="#cb11-40" aria-hidden="true" tabindex="-1"></a>    plt.close()</span>
<span id="cb11-41"><a href="#cb11-41" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-42"><a href="#cb11-42" aria-hidden="true" tabindex="-1"></a>visualize_dequantization(quants<span class="op">=</span><span class="dv">8</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="NF_image_modeling_files/figure-html/cell-9-output-1.svg" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>The visualized distribution show the sub-volumes that are assigned to the different discrete values. The value <span class="math inline">\(0\)</span> has its volume between <span class="math inline">\([-\infty, -1.9)\)</span>, the value <span class="math inline">\(1\)</span> is represented by the interval <span class="math inline">\([-1.9, -1.1)\)</span>, etc. The volume for each discrete value has the same probability mass. That’s why the volumes close to the center (e.g.&nbsp;3 and 4) have a smaller area on the z-axis as others (<span class="math inline">\(z\)</span> is being used to denote the output of the whole dequantization flow).</p>
<p>Effectively, the consecutive normalizing flow models discrete images by the following objective:</p>
<p><span class="math display">\[\log p(x) = \log \mathbb{E}_{u\sim q(u|x)}\left[\frac{p(x+u)}{q(u|x)} \right] \geq \mathbb{E}_{u}\left[\log \frac{p(x+u)}{q(u|x)} \right]\]</span></p>
<p>Although normalizing flows are exact in likelihood, we have a lower bound. Specifically, this is an example of the Jensen inequality because we need to move the log into the expectation so we can use Monte-carlo estimates. In general, this bound is considerably smaller than the ELBO in variational autoencoders. Actually, we can reduce the bound ourselves by estimating the expectation not by one, but by <span class="math inline">\(M\)</span> samples. In other words, we can apply importance sampling which leads to the following inequality:</p>
<p><span class="math display">\[\log p(x) = \log \mathbb{E}_{u\sim q(u|x)}\left[\frac{p(x+u)}{q(u|x)} \right] \geq \mathbb{E}_{u}\left[\log \frac{1}{M} \sum_{m=1}^{M} \frac{p(x+u_m)}{q(u_m|x)} \right] \geq \mathbb{E}_{u}\left[\log \frac{p(x+u)}{q(u|x)} \right]\]</span></p>
<p>The importance sampling <span class="math inline">\(\frac{1}{M} \sum_{m=1}^{M} \frac{p(x+u_m)}{q(u_m|x)}\)</span> becomes <span class="math inline">\(\mathbb{E}_{u\sim q(u|x)}\left[\frac{p(x+u)}{q(u|x)} \right]\)</span> if <span class="math inline">\(M\to \infty\)</span>, so that the more samples we use, the tighter the bound is. During testing, we can make use of this property and have it implemented in <code>test_step</code> in <code>ImageFlow</code>. In theory, we could also use this tighter bound during training. However, related work has shown that this does not necessarily lead to an improvement given the additional computational cost, and it is more efficient to stick with a single estimate [5].</p>
</section>
<section id="variational-dequantization" class="level3">
<h3 class="anchored" data-anchor-id="variational-dequantization">Variational Dequantization</h3>
<p>Dequantization uses a uniform distribution for the noise <span class="math inline">\(u\)</span> which effectively leads to images being represented as hypercubes (cube in high dimensions) with sharp borders. However, modeling such sharp borders is not easy for a flow as it uses smooth transformations to convert it into a Gaussian distribution.</p>
<p>Another way of looking at it is if we change the prior distribution in the previous visualization. Imagine we have independent Gaussian noise on pixels which is commonly the case for any real-world taken picture. Therefore, the flow would have to model a distribution as above, but with the individual volumes scaled as follows:</p>
<div id="cell-24" class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>visualize_dequantization(quants<span class="op">=</span><span class="dv">8</span>, prior<span class="op">=</span>np.array([<span class="fl">0.075</span>, <span class="fl">0.2</span>, <span class="fl">0.4</span>, <span class="fl">0.2</span>, <span class="fl">0.075</span>, <span class="fl">0.025</span>, <span class="fl">0.0125</span>, <span class="fl">0.0125</span>]))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="NF_image_modeling_files/figure-html/cell-10-output-1.svg" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Transforming such a probability into a Gaussian is a difficult task, especially with such hard borders. Dequantization has therefore been extended to more sophisticated, learnable distributions beyond uniform in a variational framework. In particular, if we remember the learning objective <span class="math inline">\(\log p(x) = \log \mathbb{E}_{u}\left[\frac{p(x+u)}{q(u|x)} \right]\)</span>, the uniform distribution can be replaced by a learned distribution <span class="math inline">\(q_{\theta}(u|x)\)</span> with support over <span class="math inline">\(u\in[0,1)^D\)</span>. This approach is called Variational Dequantization and has been proposed by Ho et al.&nbsp;[3]. How can we learn such a distribution? We can use a second normalizing flow that takes <span class="math inline">\(x\)</span> as external input and learns a flexible distribution over <span class="math inline">\(u\)</span>. To ensure a support over <span class="math inline">\([0,1)^D\)</span>, we can apply a sigmoid activation function as final flow transformation.</p>
<p>Inheriting the original dequantization class, we can implement variational dequantization as follows:</p>
<div id="cell-26" class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> VariationalDequantization(Dequantization):</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    var_flows : Sequence[nn.Module] <span class="op">=</span> <span class="va">None</span>  <span class="co"># A list of flow transformations to use for modeling q(u|x)</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> dequant(<span class="va">self</span>, z, ldj, rng):</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>        z <span class="op">=</span> z.astype(jnp.float32)</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>        img <span class="op">=</span> (z <span class="op">/</span> <span class="fl">255.0</span>) <span class="op">*</span> <span class="dv">2</span> <span class="op">-</span> <span class="dv">1</span> <span class="co"># We condition the flows on x, i.e. the original image</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Prior of u is a uniform distribution as before</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>        <span class="co"># As most flow transformations are defined on [-infinity,+infinity], we apply an inverse sigmoid first.</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>        rng, uniform_rng <span class="op">=</span> random.split(rng)</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>        deq_noise <span class="op">=</span> random.uniform(uniform_rng, z.shape)</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>        deq_noise, ldj <span class="op">=</span> <span class="va">self</span>.sigmoid(deq_noise, ldj, reverse<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.var_flows <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> flow <span class="kw">in</span> <span class="va">self</span>.var_flows:</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>                deq_noise, ldj, rng <span class="op">=</span> flow(deq_noise, ldj, rng, reverse<span class="op">=</span><span class="va">False</span>, orig_img<span class="op">=</span>img)</span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>        deq_noise, ldj <span class="op">=</span> <span class="va">self</span>.sigmoid(deq_noise, ldj, reverse<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>        <span class="co"># After the flows, apply u as in standard dequantization</span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>        z <span class="op">=</span> (z <span class="op">+</span> deq_noise) <span class="op">/</span> <span class="fl">256.0</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>        ldj <span class="op">-=</span> np.log(<span class="fl">256.0</span>) <span class="op">*</span> np.prod(z.shape[<span class="dv">1</span>:])</span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> z, ldj, rng</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Variational dequantization can be used as a substitute for dequantization. We will compare dequantization and variational dequantization in later experiments.</p>
</section>
<section id="coupling-layers" class="level3">
<h3 class="anchored" data-anchor-id="coupling-layers">Coupling layers</h3>
<p>Next, we look at possible transformations to apply inside the flow. A recent popular flow layer, which works well in combination with deep neural networks, is the coupling layer introduced by Dinh et al.&nbsp;[1]. The input <span class="math inline">\(z\)</span> is arbitrarily split into two parts, <span class="math inline">\(z_{1:j}\)</span> and <span class="math inline">\(z_{j+1:d}\)</span>, of which the first remains unchanged by the flow. Yet, <span class="math inline">\(z_{1:j}\)</span> is used to parameterize the transformation for the second part, <span class="math inline">\(z_{j+1:d}\)</span>. Various transformations have been proposed in recent time [3,4], but here we will settle for the simplest and most efficient one: affine coupling. In this coupling layer, we apply an affine transformation by shifting the input by a bias <span class="math inline">\(\mu\)</span> and scale it by <span class="math inline">\(\sigma\)</span>. In other words, our transformation looks as follows:</p>
<p><span class="math display">\[z'_{j+1:d} = \mu_{\theta}(z_{1:j}) + \sigma_{\theta}(z_{1:j}) \odot z_{j+1:d}\]</span></p>
<p>The functions <span class="math inline">\(\mu\)</span> and <span class="math inline">\(\sigma\)</span> are implemented as a shared neural network, and the sum and multiplication are performed element-wise. The log-determinant Jacobian (LDJ) is thereby the sum of the logs of the scaling factors: <span class="math inline">\(\sum_i \left[\log \sigma_{\theta}(z_{1:j})\right]_i\)</span>. Inverting the layer can as simply be done as subtracting the bias and dividing by the scale:</p>
<p><span class="math display">\[z_{j+1:d} = \left(z'_{j+1:d} - \mu_{\theta}(z_{1:j})\right) / \sigma_{\theta}(z_{1:j})\]</span></p>
<p>We can also visualize the coupling layer in form of a computation graph, where <span class="math inline">\(z_1\)</span> represents <span class="math inline">\(z_{1:j}\)</span>, and <span class="math inline">\(z_2\)</span> represents <span class="math inline">\(z_{j+1:d}\)</span>:</p>
<center width="100%" style="padding: 10px">
<img src="../../tutorial11/coupling_flow.svg" width="450px">
</center>
<p>In our implementation, we will realize the splitting of variables as masking. The variables to be transformed, <span class="math inline">\(z_{j+1:d}\)</span>, are masked when passing <span class="math inline">\(z\)</span> to the shared network to predict the transformation parameters. When applying the transformation, we mask the parameters for <span class="math inline">\(z_{1:j}\)</span> so that we have an identity operation for those variables:</p>
<div id="cell-29" class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> CouplingLayer(nn.Module):</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    network : nn.Module  <span class="co"># NN to use in the flow for predicting mu and sigma</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    mask : np.ndarray  <span class="co"># Binary mask where 0 denotes that the element should be transformed, and 1 not.</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    c_in : <span class="bu">int</span>  <span class="co"># Number of input channels</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> setup(<span class="va">self</span>):</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.scaling_factor <span class="op">=</span> <span class="va">self</span>.param(<span class="st">'scaling_factor'</span>,</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>                                         nn.initializers.zeros,</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>                                         (<span class="va">self</span>.c_in,))</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__call__</span>(<span class="va">self</span>, z, ldj, rng, reverse<span class="op">=</span><span class="va">False</span>, orig_img<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a><span class="co">        Inputs:</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a><span class="co">            z - Latent input to the flow</span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a><span class="co">            ldj - The current ldj of the previous flows. </span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a><span class="co">                  The ldj of this layer will be added to this tensor.</span></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a><span class="co">            rng - PRNG state</span></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a><span class="co">            reverse - If True, we apply the inverse of the layer.</span></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a><span class="co">            orig_img (optional) - Only needed in VarDeq. Allows external</span></span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a><span class="co">                                  input to condition the flow on (e.g. original image)</span></span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Apply network to masked input</span></span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a>        z_in <span class="op">=</span> z <span class="op">*</span> <span class="va">self</span>.mask</span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> orig_img <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a>            nn_out <span class="op">=</span> <span class="va">self</span>.network(z_in)</span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true" tabindex="-1"></a>            nn_out <span class="op">=</span> <span class="va">self</span>.network(jnp.concatenate([z_in, orig_img], axis<span class="op">=-</span><span class="dv">1</span>))</span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true" tabindex="-1"></a>        s, t <span class="op">=</span> nn_out.split(<span class="dv">2</span>, axis<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb14-29"><a href="#cb14-29" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb14-30"><a href="#cb14-30" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Stabilize scaling output</span></span>
<span id="cb14-31"><a href="#cb14-31" aria-hidden="true" tabindex="-1"></a>        s_fac <span class="op">=</span> jnp.exp(<span class="va">self</span>.scaling_factor).reshape(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb14-32"><a href="#cb14-32" aria-hidden="true" tabindex="-1"></a>        s <span class="op">=</span> nn.tanh(s <span class="op">/</span> s_fac) <span class="op">*</span> s_fac</span>
<span id="cb14-33"><a href="#cb14-33" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb14-34"><a href="#cb14-34" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Mask outputs (only transform the second part)</span></span>
<span id="cb14-35"><a href="#cb14-35" aria-hidden="true" tabindex="-1"></a>        s <span class="op">=</span> s <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> <span class="va">self</span>.mask)</span>
<span id="cb14-36"><a href="#cb14-36" aria-hidden="true" tabindex="-1"></a>        t <span class="op">=</span> t <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> <span class="va">self</span>.mask)</span>
<span id="cb14-37"><a href="#cb14-37" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb14-38"><a href="#cb14-38" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Affine transformation</span></span>
<span id="cb14-39"><a href="#cb14-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> reverse:</span>
<span id="cb14-40"><a href="#cb14-40" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Whether we first shift and then scale, or the other way round,</span></span>
<span id="cb14-41"><a href="#cb14-41" aria-hidden="true" tabindex="-1"></a>            <span class="co"># is a design choice, and usually does not have a big impact</span></span>
<span id="cb14-42"><a href="#cb14-42" aria-hidden="true" tabindex="-1"></a>            z <span class="op">=</span> (z <span class="op">+</span> t) <span class="op">*</span> jnp.exp(s)</span>
<span id="cb14-43"><a href="#cb14-43" aria-hidden="true" tabindex="-1"></a>            ldj <span class="op">+=</span> s.<span class="bu">sum</span>(axis<span class="op">=</span>[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>])</span>
<span id="cb14-44"><a href="#cb14-44" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb14-45"><a href="#cb14-45" aria-hidden="true" tabindex="-1"></a>            z <span class="op">=</span> (z <span class="op">*</span> jnp.exp(<span class="op">-</span>s)) <span class="op">-</span> t</span>
<span id="cb14-46"><a href="#cb14-46" aria-hidden="true" tabindex="-1"></a>            ldj <span class="op">-=</span> s.<span class="bu">sum</span>(axis<span class="op">=</span>[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>])</span>
<span id="cb14-47"><a href="#cb14-47" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb14-48"><a href="#cb14-48" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> z, ldj, rng</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>For stabilization purposes, we apply a <span class="math inline">\(\tanh\)</span> activation function on the scaling output. This prevents sudden large output values for the scaling that can destabilize training. To still allow scaling factors smaller or larger than -1 and 1 respectively, we have a learnable parameter per dimension, called <code>scaling_factor</code>. This scales the tanh to different limits. Below, we visualize the effect of the scaling factor on the output activation of the scaling terms:</p>
<div id="cell-31" class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> jnp.arange(<span class="op">-</span><span class="dv">5</span>,<span class="dv">5</span>,<span class="fl">0.01</span>)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>scaling_factors <span class="op">=</span> [<span class="fl">0.5</span>, <span class="dv">1</span>, <span class="dv">2</span>]</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>sns.<span class="bu">set</span>()</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">12</span>,<span class="dv">3</span>))</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, scale <span class="kw">in</span> <span class="bu">enumerate</span>(scaling_factors):</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> nn.tanh(x <span class="op">/</span> scale) <span class="op">*</span> scale</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>    ax[i].plot(x, y)</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    ax[i].set_title(<span class="st">"Scaling factor: "</span> <span class="op">+</span> <span class="bu">str</span>(scale))</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    ax[i].set_ylim(<span class="op">-</span><span class="dv">3</span>, <span class="dv">3</span>)</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>plt.subplots_adjust(wspace<span class="op">=</span><span class="fl">0.4</span>)</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>sns.reset_orig()</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="NF_image_modeling_files/figure-html/cell-13-output-1.svg" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Coupling layers generalize to any masking technique we could think of. However, the most common approach for images is to split the input <span class="math inline">\(z\)</span> in half, using a checkerboard mask or channel mask. A checkerboard mask splits the variables across the height and width dimensions and assigns each other pixel to <span class="math inline">\(z_{j+1:d}\)</span>. Thereby, the mask is shared across channels. In contrast, the channel mask assigns half of the channels to <span class="math inline">\(z_{j+1:d}\)</span>, and the other half to <span class="math inline">\(z_{1:j+1}\)</span>. Note that when we apply multiple coupling layers, we invert the masking for each other layer so that each variable is transformed a similar amount of times.</p>
<p>Let’s implement a function that creates a checkerboard mask and a channel mask for us:</p>
<div id="cell-33" class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_checkerboard_mask(h, w, invert<span class="op">=</span><span class="va">False</span>):</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    x, y <span class="op">=</span> jnp.arange(h, dtype<span class="op">=</span>jnp.int32), jnp.arange(w, dtype<span class="op">=</span>jnp.int32)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    xx, yy <span class="op">=</span> jnp.meshgrid(x, y, indexing<span class="op">=</span><span class="st">'ij'</span>)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    mask <span class="op">=</span> jnp.fmod(xx <span class="op">+</span> yy, <span class="dv">2</span>)</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    mask <span class="op">=</span> mask.astype(jnp.float32).reshape(<span class="dv">1</span>, h, w, <span class="dv">1</span>)</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> invert:</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>        mask <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> mask</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> mask</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_channel_mask(c_in, invert<span class="op">=</span><span class="va">False</span>):</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>    mask <span class="op">=</span> jnp.concatenate([</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>                jnp.ones((c_in<span class="op">//</span><span class="dv">2</span>,), dtype<span class="op">=</span>jnp.float32), </span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>                jnp.zeros((c_in<span class="op">-</span>c_in<span class="op">//</span><span class="dv">2</span>,), dtype<span class="op">=</span>jnp.float32)</span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>            ])</span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>    mask <span class="op">=</span> mask.reshape(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, c_in)</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> invert:</span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>        mask <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> mask</span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> mask</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can also visualize the corresponding masks for an image of size <span class="math inline">\(8\times 8\times 2\)</span> (2 channels):</p>
<div id="cell-35" class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>checkerboard_mask <span class="op">=</span> create_checkerboard_mask(h<span class="op">=</span><span class="dv">8</span>, w<span class="op">=</span><span class="dv">8</span>).repeat(<span class="dv">2</span>, <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>channel_mask <span class="op">=</span> jnp.resize(create_channel_mask(c_in<span class="op">=</span><span class="dv">2</span>), (<span class="dv">1</span>,<span class="dv">8</span>,<span class="dv">8</span>,<span class="dv">2</span>))</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>show_imgs(checkerboard_mask.swapaxes(<span class="dv">0</span>, <span class="dv">3</span>), <span class="st">"Checkerboard mask"</span>)</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>show_imgs(channel_mask.swapaxes(<span class="dv">0</span>, <span class="dv">3</span>), <span class="st">"Channel mask"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="NF_image_modeling_files/figure-html/cell-15-output-1.svg" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="NF_image_modeling_files/figure-html/cell-15-output-2.svg" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>As a last aspect of coupling layers, we need to decide for the deep neural network we want to apply in the coupling layers. The input to the layers is an image, and hence we stick with a CNN. Because the input to a transformation depends on all transformations before, it is crucial to ensure a good gradient flow through the CNN back to the input, which can be optimally achieved by a ResNet-like architecture. Specifically, we use a Gated ResNet that adds a <span class="math inline">\(\sigma\)</span>-gate to the skip connection, similarly to the input gate in LSTMs. The details are not necessarily important here, and the network is strongly inspired from Flow++ [3] in case you are interested in building even stronger models.</p>
<div id="cell-37" class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ConcatELU(nn.Module):</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Activation function that applies ELU in both direction (inverted and plain). </span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="co">    Allows non-linearity while providing strong gradients for any input (important for final convolution)</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__call__</span>(<span class="va">self</span>, x):</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> jnp.concatenate([nn.elu(x), nn.elu(<span class="op">-</span>x)], axis<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> GatedConv(nn.Module):</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">""" This module applies a two-layer convolutional ResNet block with input gate """</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>    c_in : <span class="bu">int</span>  <span class="co"># Number of input channels</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>    c_hidden : <span class="bu">int</span>  <span class="co"># Number of hidden dimensions</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>    <span class="at">@nn.compact</span></span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__call__</span>(<span class="va">self</span>, x):</span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>        out <span class="op">=</span> nn.Sequential([</span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>            ConcatELU(),</span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a>            nn.Conv(<span class="va">self</span>.c_hidden, kernel_size<span class="op">=</span>(<span class="dv">3</span>, <span class="dv">3</span>)),</span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a>            ConcatELU(),</span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a>            nn.Conv(<span class="dv">2</span><span class="op">*</span><span class="va">self</span>.c_in, kernel_size<span class="op">=</span>(<span class="dv">1</span>, <span class="dv">1</span>))</span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a>        ])(x)</span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a>        val, gate <span class="op">=</span> out.split(<span class="dv">2</span>, axis<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> x <span class="op">+</span> val <span class="op">*</span> nn.sigmoid(gate)</span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> GatedConvNet(nn.Module):</span>
<span id="cb18-29"><a href="#cb18-29" aria-hidden="true" tabindex="-1"></a>    c_hidden : <span class="bu">int</span>  <span class="co"># Number of hidden dimensions to use within the network</span></span>
<span id="cb18-30"><a href="#cb18-30" aria-hidden="true" tabindex="-1"></a>    c_out : <span class="bu">int</span>  <span class="co"># Number of output channels</span></span>
<span id="cb18-31"><a href="#cb18-31" aria-hidden="true" tabindex="-1"></a>    num_layers : <span class="bu">int</span> <span class="op">=</span> <span class="dv">3</span> <span class="co"># Number of gated ResNet blocks to apply</span></span>
<span id="cb18-32"><a href="#cb18-32" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-33"><a href="#cb18-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> setup(<span class="va">self</span>):</span>
<span id="cb18-34"><a href="#cb18-34" aria-hidden="true" tabindex="-1"></a>        layers <span class="op">=</span> []</span>
<span id="cb18-35"><a href="#cb18-35" aria-hidden="true" tabindex="-1"></a>        layers <span class="op">+=</span> [nn.Conv(<span class="va">self</span>.c_hidden, kernel_size<span class="op">=</span>(<span class="dv">3</span>, <span class="dv">3</span>))]</span>
<span id="cb18-36"><a href="#cb18-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> layer_index <span class="kw">in</span> <span class="bu">range</span>(<span class="va">self</span>.num_layers):</span>
<span id="cb18-37"><a href="#cb18-37" aria-hidden="true" tabindex="-1"></a>            layers <span class="op">+=</span> [GatedConv(<span class="va">self</span>.c_hidden, <span class="va">self</span>.c_hidden),</span>
<span id="cb18-38"><a href="#cb18-38" aria-hidden="true" tabindex="-1"></a>                       nn.LayerNorm()]</span>
<span id="cb18-39"><a href="#cb18-39" aria-hidden="true" tabindex="-1"></a>        layers <span class="op">+=</span> [ConcatELU(),</span>
<span id="cb18-40"><a href="#cb18-40" aria-hidden="true" tabindex="-1"></a>                   nn.Conv(<span class="va">self</span>.c_out, kernel_size<span class="op">=</span>(<span class="dv">3</span>, <span class="dv">3</span>),</span>
<span id="cb18-41"><a href="#cb18-41" aria-hidden="true" tabindex="-1"></a>                           kernel_init<span class="op">=</span>nn.initializers.zeros)]</span>
<span id="cb18-42"><a href="#cb18-42" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.nn <span class="op">=</span> nn.Sequential(layers)</span>
<span id="cb18-43"><a href="#cb18-43" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-44"><a href="#cb18-44" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__call__</span>(<span class="va">self</span>, x):</span>
<span id="cb18-45"><a href="#cb18-45" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.nn(x)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="training-loop" class="level3">
<h3 class="anchored" data-anchor-id="training-loop">Training loop</h3>
<p>Finally, we can add Dequantization, Variational Dequantization and Coupling Layers together to build our full normalizing flow on MNIST images. We apply 8 coupling layers in the main flow, and 4 for variational dequantization if applied. We apply a checkerboard mask throughout the network as with a single channel (black-white images), we cannot apply channel mask. The overall architecture is visualized below.</p>
<center width="100%" style="padding: 20px">
<img src="../../tutorial11/vanilla_flow.svg" width="900px">
</center>
<div id="cell-39" class="cell" data-scrolled="true" data-execution_count="17">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_simple_flow(use_vardeq<span class="op">=</span><span class="va">True</span>):</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    flow_layers <span class="op">=</span> []</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> use_vardeq:</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>        vardeq_layers <span class="op">=</span> [CouplingLayer(network<span class="op">=</span>GatedConvNet(c_out<span class="op">=</span><span class="dv">2</span>, c_hidden<span class="op">=</span><span class="dv">16</span>),</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>                                       mask<span class="op">=</span>create_checkerboard_mask(h<span class="op">=</span><span class="dv">28</span>, w<span class="op">=</span><span class="dv">28</span>, invert<span class="op">=</span>(i<span class="op">%</span><span class="dv">2</span><span class="op">==</span><span class="dv">1</span>)),</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>                                       c_in<span class="op">=</span><span class="dv">1</span>) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">4</span>)]</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>        flow_layers <span class="op">+=</span> [VariationalDequantization(var_flows<span class="op">=</span>vardeq_layers)]</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>        flow_layers <span class="op">+=</span> [Dequantization()]</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">8</span>):</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>        flow_layers <span class="op">+=</span> [CouplingLayer(network<span class="op">=</span>GatedConvNet(c_out<span class="op">=</span><span class="dv">2</span>, c_hidden<span class="op">=</span><span class="dv">32</span>),</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>                                      mask<span class="op">=</span>create_checkerboard_mask(h<span class="op">=</span><span class="dv">28</span>, w<span class="op">=</span><span class="dv">28</span>, invert<span class="op">=</span>(i<span class="op">%</span><span class="dv">2</span><span class="op">==</span><span class="dv">1</span>)),</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>                                      c_in<span class="op">=</span><span class="dv">1</span>)]</span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>    flow_model <span class="op">=</span> ImageFlow(flow_layers)</span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> flow_model</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>For implementing the training loop, we use a similar trainer module as we have done in several tutorials before. Note that we again provide pre-trained models (see later on in the notebook) as normalizing flows are particularly expensive to train. We have also run validation and testing as this can take some time as well with the added importance sampling.</p>
<div id="cell-41" class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> TrainerModule:</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, model_name, flow, lr<span class="op">=</span><span class="fl">1e-3</span>, seed<span class="op">=</span><span class="dv">42</span>):</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.model_name <span class="op">=</span> model_name</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.lr <span class="op">=</span> lr</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.seed <span class="op">=</span> seed</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Create empty model. Note: no parameters yet</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.model <span class="op">=</span> flow</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Prepare logging</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.exmp_imgs <span class="op">=</span> <span class="bu">next</span>(<span class="bu">iter</span>(train_exmp_loader))[<span class="dv">0</span>]</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.log_dir <span class="op">=</span> os.path.join(CHECKPOINT_PATH, <span class="va">self</span>.model_name)</span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.logger <span class="op">=</span> SummaryWriter(log_dir<span class="op">=</span><span class="va">self</span>.log_dir)</span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Create jitted training and eval functions</span></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.create_functions()</span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Initialize model</span></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.init_model()</span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> create_functions(<span class="va">self</span>):</span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Training function</span></span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a>        <span class="kw">def</span> train_step(state, rng, batch):</span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a>            imgs, _ <span class="op">=</span> batch</span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a>            loss_fn <span class="op">=</span> <span class="kw">lambda</span> params: <span class="va">self</span>.model.<span class="bu">apply</span>({<span class="st">'params'</span>: params}, imgs, rng, testing<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true" tabindex="-1"></a>            (loss, rng), grads <span class="op">=</span> jax.value_and_grad(loss_fn, has_aux<span class="op">=</span><span class="va">True</span>)(state.params)  <span class="co"># Get loss and gradients for loss</span></span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true" tabindex="-1"></a>            state <span class="op">=</span> state.apply_gradients(grads<span class="op">=</span>grads)  <span class="co"># Optimizer update step</span></span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> state, rng, loss</span>
<span id="cb20-27"><a href="#cb20-27" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.train_step <span class="op">=</span> jax.jit(train_step)</span>
<span id="cb20-28"><a href="#cb20-28" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Eval function, which is separately jitted for validation and testing</span></span>
<span id="cb20-29"><a href="#cb20-29" aria-hidden="true" tabindex="-1"></a>        <span class="kw">def</span> eval_step(state, rng, batch, testing):</span>
<span id="cb20-30"><a href="#cb20-30" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">self</span>.model.<span class="bu">apply</span>({<span class="st">'params'</span>: state.params}, batch[<span class="dv">0</span>], rng, testing<span class="op">=</span>testing)</span>
<span id="cb20-31"><a href="#cb20-31" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.eval_step <span class="op">=</span> jax.jit(eval_step, static_argnums<span class="op">=</span>(<span class="dv">3</span>,))</span>
<span id="cb20-32"><a href="#cb20-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-33"><a href="#cb20-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> init_model(<span class="va">self</span>):</span>
<span id="cb20-34"><a href="#cb20-34" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Initialize model</span></span>
<span id="cb20-35"><a href="#cb20-35" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.rng <span class="op">=</span> jax.random.PRNGKey(<span class="va">self</span>.seed)</span>
<span id="cb20-36"><a href="#cb20-36" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.rng, init_rng, flow_rng <span class="op">=</span> jax.random.split(<span class="va">self</span>.rng, <span class="dv">3</span>)</span>
<span id="cb20-37"><a href="#cb20-37" aria-hidden="true" tabindex="-1"></a>        params <span class="op">=</span> <span class="va">self</span>.model.init(init_rng, <span class="va">self</span>.exmp_imgs, flow_rng)[<span class="st">'params'</span>]</span>
<span id="cb20-38"><a href="#cb20-38" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Initialize learning rate schedule and optimizer</span></span>
<span id="cb20-39"><a href="#cb20-39" aria-hidden="true" tabindex="-1"></a>        lr_schedule <span class="op">=</span> optax.exponential_decay(</span>
<span id="cb20-40"><a href="#cb20-40" aria-hidden="true" tabindex="-1"></a>            init_value<span class="op">=</span><span class="va">self</span>.lr,</span>
<span id="cb20-41"><a href="#cb20-41" aria-hidden="true" tabindex="-1"></a>            transition_steps<span class="op">=</span><span class="bu">len</span>(train_data_loader),</span>
<span id="cb20-42"><a href="#cb20-42" aria-hidden="true" tabindex="-1"></a>            decay_rate<span class="op">=</span><span class="fl">0.99</span>,</span>
<span id="cb20-43"><a href="#cb20-43" aria-hidden="true" tabindex="-1"></a>            end_value<span class="op">=</span><span class="fl">0.01</span><span class="op">*</span><span class="va">self</span>.lr</span>
<span id="cb20-44"><a href="#cb20-44" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb20-45"><a href="#cb20-45" aria-hidden="true" tabindex="-1"></a>        optimizer <span class="op">=</span> optax.chain(</span>
<span id="cb20-46"><a href="#cb20-46" aria-hidden="true" tabindex="-1"></a>            optax.clip_by_global_norm(<span class="fl">1.0</span>),  <span class="co"># Clip gradients at 1</span></span>
<span id="cb20-47"><a href="#cb20-47" aria-hidden="true" tabindex="-1"></a>            optax.adam(lr_schedule)</span>
<span id="cb20-48"><a href="#cb20-48" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb20-49"><a href="#cb20-49" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Initialize training state</span></span>
<span id="cb20-50"><a href="#cb20-50" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.state <span class="op">=</span> train_state.TrainState.create(apply_fn<span class="op">=</span><span class="va">self</span>.model.<span class="bu">apply</span>, params<span class="op">=</span>params, tx<span class="op">=</span>optimizer)</span>
<span id="cb20-51"><a href="#cb20-51" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb20-52"><a href="#cb20-52" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> train_model(<span class="va">self</span>, train_loader, val_loader, num_epochs<span class="op">=</span><span class="dv">500</span>):</span>
<span id="cb20-53"><a href="#cb20-53" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Train model for defined number of epochs</span></span>
<span id="cb20-54"><a href="#cb20-54" aria-hidden="true" tabindex="-1"></a>        best_eval <span class="op">=</span> <span class="fl">1e6</span></span>
<span id="cb20-55"><a href="#cb20-55" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> epoch_idx <span class="kw">in</span> tqdm(<span class="bu">range</span>(<span class="dv">1</span>, num_epochs<span class="op">+</span><span class="dv">1</span>)):</span>
<span id="cb20-56"><a href="#cb20-56" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.train_epoch(train_loader, epoch<span class="op">=</span>epoch_idx)</span>
<span id="cb20-57"><a href="#cb20-57" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> epoch_idx <span class="op">%</span> <span class="dv">5</span> <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb20-58"><a href="#cb20-58" aria-hidden="true" tabindex="-1"></a>                eval_bpd <span class="op">=</span> <span class="va">self</span>.eval_model(val_loader, testing<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb20-59"><a href="#cb20-59" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.logger.add_scalar(<span class="st">'val/bpd'</span>, eval_bpd, global_step<span class="op">=</span>epoch_idx)</span>
<span id="cb20-60"><a href="#cb20-60" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> eval_bpd <span class="op">&lt;</span> best_eval:</span>
<span id="cb20-61"><a href="#cb20-61" aria-hidden="true" tabindex="-1"></a>                    best_eval <span class="op">=</span> eval_bpd</span>
<span id="cb20-62"><a href="#cb20-62" aria-hidden="true" tabindex="-1"></a>                    <span class="va">self</span>.save_model(step<span class="op">=</span>epoch_idx)</span>
<span id="cb20-63"><a href="#cb20-63" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.logger.flush()</span>
<span id="cb20-64"><a href="#cb20-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-65"><a href="#cb20-65" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> train_epoch(<span class="va">self</span>, data_loader, epoch):</span>
<span id="cb20-66"><a href="#cb20-66" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Train model for one epoch, and log avg loss</span></span>
<span id="cb20-67"><a href="#cb20-67" aria-hidden="true" tabindex="-1"></a>        avg_loss <span class="op">=</span> <span class="fl">0.</span></span>
<span id="cb20-68"><a href="#cb20-68" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> batch <span class="kw">in</span> tqdm(data_loader, leave<span class="op">=</span><span class="va">False</span>):</span>
<span id="cb20-69"><a href="#cb20-69" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.state, <span class="va">self</span>.rng, loss <span class="op">=</span> <span class="va">self</span>.train_step(<span class="va">self</span>.state, <span class="va">self</span>.rng, batch)</span>
<span id="cb20-70"><a href="#cb20-70" aria-hidden="true" tabindex="-1"></a>            avg_loss <span class="op">+=</span> loss</span>
<span id="cb20-71"><a href="#cb20-71" aria-hidden="true" tabindex="-1"></a>        avg_loss <span class="op">/=</span> <span class="bu">len</span>(data_loader)</span>
<span id="cb20-72"><a href="#cb20-72" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.logger.add_scalar(<span class="st">'train/bpd'</span>, avg_loss.item(), global_step<span class="op">=</span>epoch)</span>
<span id="cb20-73"><a href="#cb20-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-74"><a href="#cb20-74" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> eval_model(<span class="va">self</span>, data_loader, testing<span class="op">=</span><span class="va">False</span>):</span>
<span id="cb20-75"><a href="#cb20-75" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Test model on all images of a data loader and return avg loss</span></span>
<span id="cb20-76"><a href="#cb20-76" aria-hidden="true" tabindex="-1"></a>        losses <span class="op">=</span> []</span>
<span id="cb20-77"><a href="#cb20-77" aria-hidden="true" tabindex="-1"></a>        batch_sizes <span class="op">=</span> []</span>
<span id="cb20-78"><a href="#cb20-78" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> batch <span class="kw">in</span> data_loader:</span>
<span id="cb20-79"><a href="#cb20-79" aria-hidden="true" tabindex="-1"></a>            loss, <span class="va">self</span>.rng <span class="op">=</span> <span class="va">self</span>.eval_step(<span class="va">self</span>.state, <span class="va">self</span>.rng, batch, testing<span class="op">=</span>testing)</span>
<span id="cb20-80"><a href="#cb20-80" aria-hidden="true" tabindex="-1"></a>            losses.append(loss)</span>
<span id="cb20-81"><a href="#cb20-81" aria-hidden="true" tabindex="-1"></a>            batch_sizes.append(batch[<span class="dv">0</span>].shape[<span class="dv">0</span>])</span>
<span id="cb20-82"><a href="#cb20-82" aria-hidden="true" tabindex="-1"></a>        losses_np <span class="op">=</span> np.stack(jax.device_get(losses))</span>
<span id="cb20-83"><a href="#cb20-83" aria-hidden="true" tabindex="-1"></a>        batch_sizes_np <span class="op">=</span> np.stack(batch_sizes)</span>
<span id="cb20-84"><a href="#cb20-84" aria-hidden="true" tabindex="-1"></a>        avg_loss <span class="op">=</span> (losses_np <span class="op">*</span> batch_sizes_np).<span class="bu">sum</span>() <span class="op">/</span> batch_sizes_np.<span class="bu">sum</span>()</span>
<span id="cb20-85"><a href="#cb20-85" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> avg_loss</span>
<span id="cb20-86"><a href="#cb20-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-87"><a href="#cb20-87" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> save_model(<span class="va">self</span>, step<span class="op">=</span><span class="dv">0</span>):</span>
<span id="cb20-88"><a href="#cb20-88" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Save current model at certain training iteration</span></span>
<span id="cb20-89"><a href="#cb20-89" aria-hidden="true" tabindex="-1"></a>        checkpoints.save_checkpoint(ckpt_dir<span class="op">=</span><span class="va">self</span>.log_dir, target<span class="op">=</span><span class="va">self</span>.state.params, step<span class="op">=</span>step)</span>
<span id="cb20-90"><a href="#cb20-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-91"><a href="#cb20-91" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> load_model(<span class="va">self</span>, pretrained<span class="op">=</span><span class="va">False</span>):</span>
<span id="cb20-92"><a href="#cb20-92" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Load model. We use different checkpoint for pretrained models</span></span>
<span id="cb20-93"><a href="#cb20-93" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> pretrained:</span>
<span id="cb20-94"><a href="#cb20-94" aria-hidden="true" tabindex="-1"></a>            params <span class="op">=</span> checkpoints.restore_checkpoint(ckpt_dir<span class="op">=</span><span class="va">self</span>.log_dir, target<span class="op">=</span><span class="va">self</span>.state.params)</span>
<span id="cb20-95"><a href="#cb20-95" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb20-96"><a href="#cb20-96" aria-hidden="true" tabindex="-1"></a>            params <span class="op">=</span> checkpoints.restore_checkpoint(ckpt_dir<span class="op">=</span>os.path.join(CHECKPOINT_PATH, <span class="ss">f'</span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>model_name<span class="sc">}</span><span class="ss">.ckpt'</span>), </span>
<span id="cb20-97"><a href="#cb20-97" aria-hidden="true" tabindex="-1"></a>                                                    target<span class="op">=</span><span class="va">self</span>.state.params)</span>
<span id="cb20-98"><a href="#cb20-98" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.state <span class="op">=</span> train_state.TrainState.create(apply_fn<span class="op">=</span><span class="va">self</span>.model.<span class="bu">apply</span>, params<span class="op">=</span>params, tx<span class="op">=</span><span class="va">self</span>.state.tx)</span>
<span id="cb20-99"><a href="#cb20-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-100"><a href="#cb20-100" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> checkpoint_exists(<span class="va">self</span>):</span>
<span id="cb20-101"><a href="#cb20-101" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Check whether a pretrained model exist for this autoencoder</span></span>
<span id="cb20-102"><a href="#cb20-102" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> os.path.isfile(os.path.join(CHECKPOINT_PATH, <span class="ss">f'</span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>model_name<span class="sc">}</span><span class="ss">.ckpt'</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="cell-42" class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> train_flow(flow, model_name<span class="op">=</span><span class="st">"MNISTFlow"</span>):</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create a trainer module with specified hyperparameters</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    trainer <span class="op">=</span> TrainerModule(model_name, flow)</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> trainer.checkpoint_exists():  <span class="co"># Skip training if pretrained model exists</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>        trainer.train_model(train_data_loader,</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>                            val_loader,</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>                            num_epochs<span class="op">=</span><span class="dv">200</span>)</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>        trainer.load_model()</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>        val_bpd <span class="op">=</span> trainer.eval_model(val_loader, testing<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>        start_time <span class="op">=</span> time.time()</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>        test_bpd <span class="op">=</span> trainer.eval_model(test_loader, testing<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>        duration <span class="op">=</span> time.time() <span class="op">-</span> start_time</span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>        results <span class="op">=</span> {<span class="st">'val'</span>: val_bpd, <span class="st">'test'</span>: test_bpd, <span class="st">'time'</span>: duration <span class="op">/</span> <span class="bu">len</span>(test_loader) <span class="op">/</span> trainer.model.import_samples}</span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>        trainer.load_model(pretrained<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">with</span> <span class="bu">open</span>(os.path.join(CHECKPOINT_PATH, <span class="ss">f'</span><span class="sc">{</span>trainer<span class="sc">.</span>model_name<span class="sc">}</span><span class="ss">_results.json'</span>), <span class="st">'r'</span>) <span class="im">as</span> f:</span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>            results <span class="op">=</span> json.load(f)</span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Bind parameters to model for easier inference</span></span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a>    trainer.model_bd <span class="op">=</span> trainer.model.bind({<span class="st">'params'</span>: trainer.state.params})</span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> trainer, results</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="multi-scale-architecture" class="level2">
<h2 class="anchored" data-anchor-id="multi-scale-architecture">Multi-scale architecture</h2>
<p>One disadvantage of normalizing flows is that they operate on the exact same dimensions as the input. If the input is high-dimensional, so is the latent space, which requires larger computational cost to learn suitable transformations. However, particularly in the image domain, many pixels contain less information in the sense that we could remove them without loosing the semantical information of the image.</p>
<p>Based on this intuition, deep normalizing flows on images commonly apply a multi-scale architecture [1]. After the first <span class="math inline">\(N\)</span> flow transformations, we split off half of the latent dimensions and directly evaluate them on the prior. The other half is run through <span class="math inline">\(N\)</span> more flow transformations, and depending on the size of the input, we split it again in half or stop overall at this position. The two operations involved in this setup is <code>Squeeze</code> and <code>Split</code> which we will review more closely and implement below.</p>
<section id="squeeze-and-split" class="level3">
<h3 class="anchored" data-anchor-id="squeeze-and-split">Squeeze and Split</h3>
<p>When we want to remove half of the pixels in an image, we have the problem of deciding which variables to cut, and how to rearrange the image. Thus, the squeezing operation is commonly used before split, which divides the image into subsquares of shape <span class="math inline">\(2\times 2\times C\)</span>, and reshapes them into <span class="math inline">\(1\times 1\times 4C\)</span> blocks. Effectively, we reduce the height and width of the image by a factor of 2 while scaling the number of channels by 4. Afterwards, we can perform the split operation over channels without the need of rearranging the pixels. The smaller scale also makes the overall architecture more efficient. Visually, the squeeze operation should transform the input as follows:</p>
<center>
<img src="../../tutorial11/Squeeze_operation.svg" width="500px">
</center>
<p>The input of <span class="math inline">\(4\times 4\times 1\)</span> is scaled to <span class="math inline">\(2\times 2\times 4\)</span> following the idea of grouping the pixels in <span class="math inline">\(2\times 2\times 1\)</span> subsquares. Next, let’s try to implement this layer:</p>
<div id="cell-45" class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> SqueezeFlow(nn.Module):</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__call__</span>(<span class="va">self</span>, z, ldj, rng, reverse<span class="op">=</span><span class="va">False</span>):</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>        B, H, W, C <span class="op">=</span> z.shape</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> reverse: </span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Forward direction: H x W x C =&gt; H/2 x W/2 x 4C</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>            z <span class="op">=</span> z.reshape(B, H<span class="op">//</span><span class="dv">2</span>, <span class="dv">2</span>, W<span class="op">//</span><span class="dv">2</span>, <span class="dv">2</span>, C)</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>            z <span class="op">=</span> z.transpose((<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">5</span>))</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>            z <span class="op">=</span> z.reshape(B, H<span class="op">//</span><span class="dv">2</span>, W<span class="op">//</span><span class="dv">2</span>, <span class="dv">4</span><span class="op">*</span>C)</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>: </span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Reverse direction: H/2 x W/2 x 4C =&gt; H x W x C</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>            z <span class="op">=</span> z.reshape(B, H, W, <span class="dv">2</span>, <span class="dv">2</span>, C<span class="op">//</span><span class="dv">4</span>)</span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>            z <span class="op">=</span> z.transpose((<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">5</span>))</span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>            z <span class="op">=</span> z.reshape(B, H<span class="op">*</span><span class="dv">2</span>, W<span class="op">*</span><span class="dv">2</span>, C<span class="op">//</span><span class="dv">4</span>)</span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> z, ldj, rng</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Before moving on, we can verify our implementation by comparing our output with the example figure above:</p>
<div id="cell-47" class="cell" data-execution_count="21">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>sq_flow <span class="op">=</span> SqueezeFlow()</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>rand_img <span class="op">=</span> jnp.arange(<span class="dv">1</span>,<span class="dv">17</span>).reshape(<span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">4</span>, <span class="dv">1</span>)</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Image (before)</span><span class="ch">\n</span><span class="st">"</span>, rand_img.transpose(<span class="dv">0</span>, <span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">2</span>)) <span class="co"># Permute for readability</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>forward_img, _, _ <span class="op">=</span> sq_flow(rand_img, ldj<span class="op">=</span><span class="va">None</span>, rng<span class="op">=</span><span class="va">None</span>, reverse<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Image (forward)</span><span class="ch">\n</span><span class="st">"</span>, forward_img)</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>reconst_img, _, _ <span class="op">=</span> sq_flow(forward_img, ldj<span class="op">=</span><span class="va">None</span>, rng<span class="op">=</span><span class="va">None</span>, reverse<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Image (reverse)</span><span class="ch">\n</span><span class="st">"</span>, reconst_img.transpose(<span class="dv">0</span>, <span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">2</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Image (before)
 [[[[ 1  2  3  4]
   [ 5  6  7  8]
   [ 9 10 11 12]
   [13 14 15 16]]]]

Image (forward)
 [[[[ 1  2  5  6]
   [ 3  4  7  8]]

  [[ 9 10 13 14]
   [11 12 15 16]]]]

Image (reverse)
 [[[[ 1  2  3  4]
   [ 5  6  7  8]
   [ 9 10 11 12]
   [13 14 15 16]]]]</code></pre>
</div>
</div>
<p>The split operation divides the input into two parts, and evaluates one part directly on the prior. So that our flow operation fits to the implementation of the previous layers, we will return the prior probability of the first part as the log determinant jacobian of the layer. It has the same effect as if we would combine all variable splits at the end of the flow, and evaluate them together on the prior.</p>
<div id="cell-49" class="cell" data-execution_count="22">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> SplitFlow(nn.Module):</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__call__</span>(<span class="va">self</span>, z, ldj, rng, reverse<span class="op">=</span><span class="va">False</span>):</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> reverse:</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>            z, z_split <span class="op">=</span> z.split(<span class="dv">2</span>, axis<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>            ldj <span class="op">+=</span> jax.scipy.stats.norm.logpdf(z_split).<span class="bu">sum</span>(axis<span class="op">=</span>[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>])</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>            z_split <span class="op">=</span> random.normal(rng, z.shape)</span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>            z <span class="op">=</span> jnp.concatenate([z, z_split], axis<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>            ldj <span class="op">-=</span> jax.scipy.stats.norm.logpdf(z_split).<span class="bu">sum</span>(axis<span class="op">=</span>[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>])</span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> z, ldj, rng</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="building-a-multi-scale-flow" class="level3">
<h3 class="anchored" data-anchor-id="building-a-multi-scale-flow">Building a multi-scale flow</h3>
<p>After defining the squeeze and split operation, we are finally able to build our own multi-scale flow. Deep normalizing flows such as Glow and Flow++ [2,3] often apply a split operation directly after squeezing. However, with shallow flows, we need to be more thoughtful about where to place the split operation as we need at least a minimum amount of transformations on each variable. Our setup is inspired by the original RealNVP architecture [1] which is shallower than other, more recent state-of-the-art architectures.</p>
<p>Hence, for the MNIST dataset, we will apply the first squeeze operation after two coupling layers, but don’t apply a split operation yet. Because we have only used two coupling layers and each the variable has been only transformed once, a split operation would be too early. We apply two more coupling layers before finally applying a split flow and squeeze again. The last four coupling layers operate on a scale of <span class="math inline">\(7\times 7\times 8\)</span>. The full flow architecture is shown below.</p>
<center width="100%" style="padding: 20px">
<img src="../../tutorial11/multiscale_flow.svg" width="1100px">
</center>
<p>Note that while the feature maps inside the coupling layers reduce with the height and width of the input, the increased number of channels is not directly considered. To counteract this, we increase the hidden dimensions for the coupling layers on the squeezed input. The dimensions are often scaled by 2 as this approximately increases the computation cost by 4 canceling with the squeezing operation. However, we will choose the hidden dimensionalities <span class="math inline">\(32, 48, 64\)</span> for the three scales respectively to keep the number of parameters reasonable and show the efficiency of multi-scale architectures.</p>
<div id="cell-51" class="cell" data-execution_count="23">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_multiscale_flow():</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    flow_layers <span class="op">=</span> []</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>    vardeq_layers <span class="op">=</span> [CouplingLayer(network<span class="op">=</span>GatedConvNet(c_out<span class="op">=</span><span class="dv">2</span>, c_hidden<span class="op">=</span><span class="dv">16</span>),</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>                                   mask<span class="op">=</span>create_checkerboard_mask(h<span class="op">=</span><span class="dv">28</span>, w<span class="op">=</span><span class="dv">28</span>, invert<span class="op">=</span>(i<span class="op">%</span><span class="dv">2</span><span class="op">==</span><span class="dv">1</span>)),</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>                                   c_in<span class="op">=</span><span class="dv">1</span>) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">4</span>)]</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>    flow_layers <span class="op">+=</span> [VariationalDequantization(var_flows<span class="op">=</span>vardeq_layers)]</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>    flow_layers <span class="op">+=</span> [CouplingLayer(network<span class="op">=</span>GatedConvNet(c_out<span class="op">=</span><span class="dv">2</span>, c_hidden<span class="op">=</span><span class="dv">32</span>),</span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>                                  mask<span class="op">=</span>create_checkerboard_mask(h<span class="op">=</span><span class="dv">28</span>, w<span class="op">=</span><span class="dv">28</span>, invert<span class="op">=</span>(i<span class="op">%</span><span class="dv">2</span><span class="op">==</span><span class="dv">1</span>)),</span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>                                  c_in<span class="op">=</span><span class="dv">1</span>) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>)]</span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>    flow_layers <span class="op">+=</span> [SqueezeFlow()]</span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>):</span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a>        flow_layers <span class="op">+=</span> [CouplingLayer(network<span class="op">=</span>GatedConvNet(c_out<span class="op">=</span><span class="dv">8</span>, c_hidden<span class="op">=</span><span class="dv">48</span>),</span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a>                                      mask<span class="op">=</span>create_channel_mask(c_in<span class="op">=</span><span class="dv">4</span>, invert<span class="op">=</span>(i<span class="op">%</span><span class="dv">2</span><span class="op">==</span><span class="dv">1</span>)),</span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a>                                      c_in<span class="op">=</span><span class="dv">4</span>)]</span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true" tabindex="-1"></a>    flow_layers <span class="op">+=</span> [SplitFlow(),</span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true" tabindex="-1"></a>                    SqueezeFlow()]</span>
<span id="cb26-19"><a href="#cb26-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">4</span>):</span>
<span id="cb26-20"><a href="#cb26-20" aria-hidden="true" tabindex="-1"></a>        flow_layers <span class="op">+=</span> [CouplingLayer(network<span class="op">=</span>GatedConvNet(c_out<span class="op">=</span><span class="dv">16</span>, c_hidden<span class="op">=</span><span class="dv">64</span>),</span>
<span id="cb26-21"><a href="#cb26-21" aria-hidden="true" tabindex="-1"></a>                                      mask<span class="op">=</span>create_channel_mask(c_in<span class="op">=</span><span class="dv">8</span>, invert<span class="op">=</span>(i<span class="op">%</span><span class="dv">2</span><span class="op">==</span><span class="dv">1</span>)),</span>
<span id="cb26-22"><a href="#cb26-22" aria-hidden="true" tabindex="-1"></a>                                      c_in<span class="op">=</span><span class="dv">8</span>)]</span>
<span id="cb26-23"><a href="#cb26-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-24"><a href="#cb26-24" aria-hidden="true" tabindex="-1"></a>    flow_model <span class="op">=</span> ImageFlow(flow_layers)</span>
<span id="cb26-25"><a href="#cb26-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> flow_model</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="analysing-the-flows" class="level2">
<h2 class="anchored" data-anchor-id="analysing-the-flows">Analysing the flows</h2>
<p>In the last part of the notebook, we will train all the models we have implemented above, and try to analyze the effect of the multi-scale architecture and variational dequantization.</p>
<section id="training-flow-variants" class="level3">
<h3 class="anchored" data-anchor-id="training-flow-variants">Training flow variants</h3>
<p>Before we can analyse the flow models, we need to train them first. We provide pre-trained models that contain the validation and test performance, and run-time information. As flow models are computationally expensive, we advice you to rely on those pretrained models for a first run through the notebook.</p>
<div id="cell-53" class="cell" data-scrolled="false" data-execution_count="24">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>flow_dict <span class="op">=</span> {<span class="st">"simple"</span>: {}, <span class="st">"vardeq"</span>: {}, <span class="st">"multiscale"</span>: {}}</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>flow_dict[<span class="st">"simple"</span>][<span class="st">"model"</span>], flow_dict[<span class="st">"simple"</span>][<span class="st">"result"</span>] <span class="op">=</span> train_flow(create_simple_flow(use_vardeq<span class="op">=</span><span class="va">False</span>), model_name<span class="op">=</span><span class="st">"MNISTFlow_simple"</span>)</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>flow_dict[<span class="st">"vardeq"</span>][<span class="st">"model"</span>], flow_dict[<span class="st">"vardeq"</span>][<span class="st">"result"</span>] <span class="op">=</span> train_flow(create_simple_flow(use_vardeq<span class="op">=</span><span class="va">True</span>), model_name<span class="op">=</span><span class="st">"MNISTFlow_vardeq"</span>)</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>flow_dict[<span class="st">"multiscale"</span>][<span class="st">"model"</span>], flow_dict[<span class="st">"multiscale"</span>][<span class="st">"result"</span>] <span class="op">=</span> train_flow(create_multiscale_flow(), model_name<span class="op">=</span><span class="st">"MNISTFlow_multiscale"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can show the difference in number of parameters below:</p>
<div id="cell-55" class="cell" data-execution_count="25">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> print_num_params(model):</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>    num_params <span class="op">=</span> <span class="bu">sum</span>([np.prod(p.shape) <span class="cf">for</span> p <span class="kw">in</span> jax.tree_util.tree_leaves(model.state.params)])</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Number of parameters: </span><span class="sc">{:,}</span><span class="st">"</span>.<span class="bu">format</span>(num_params))</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>print_num_params(flow_dict[<span class="st">"simple"</span>][<span class="st">"model"</span>])</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>print_num_params(flow_dict[<span class="st">"vardeq"</span>][<span class="st">"model"</span>])</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>print_num_params(flow_dict[<span class="st">"multiscale"</span>][<span class="st">"model"</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Number of parameters: 556,312
Number of parameters: 628,388
Number of parameters: 1,711,818</code></pre>
</div>
</div>
<p>Although the multi-scale flow has almost 3 times the parameters of the single scale flow, it is not necessarily more computationally expensive than its counterpart. We will compare the runtime in the following experiments as well.</p>
</section>
<section id="density-modeling-and-sampling" class="level3">
<h3 class="anchored" data-anchor-id="density-modeling-and-sampling">Density modeling and sampling</h3>
<p>Firstly, we can compare the models on their quantitative results. The following table shows all important statistics. The inference time specifies the time needed to determine the probability for a batch of 64 images for each model, and the sampling time the duration it took to sample a batch of 64 images.</p>
<div id="cell-58" class="cell" data-scrolled="true" data-execution_count="26">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="op">%%</span>html</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;!--</span> Some HTML code to increase font size <span class="kw">in</span> the following table <span class="op">--&gt;</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>style<span class="op">&gt;</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>th {font<span class="op">-</span>size: <span class="dv">120</span><span class="op">%;</span>}</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>td {font<span class="op">-</span>size: <span class="dv">120</span><span class="op">%;</span>}</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;/</span>style<span class="op">&gt;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<!-- Some HTML code to increase font size in the following table -->
<style>
th {font-size: 120%;}
td {font-size: 120%;}
</style>
</div>
</div>
<div id="cell-59" class="cell" data-scrolled="true" data-execution_count="27">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> tabulate</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> IPython.display <span class="im">import</span> display, HTML</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>table <span class="op">=</span> [[key, </span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>          <span class="st">"</span><span class="sc">%4.3f</span><span class="st"> bpd"</span> <span class="op">%</span> flow_dict[key][<span class="st">"result"</span>][<span class="st">"val"</span>], </span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>          <span class="st">"</span><span class="sc">%4.3f</span><span class="st"> bpd"</span> <span class="op">%</span> flow_dict[key][<span class="st">"result"</span>][<span class="st">"test"</span>], </span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>          <span class="st">"</span><span class="sc">%2.1f</span><span class="st"> ms"</span> <span class="op">%</span> (<span class="dv">1000</span> <span class="op">*</span> flow_dict[key][<span class="st">"result"</span>][<span class="st">"time"</span>]),</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>          <span class="st">"</span><span class="sc">%2.1f</span><span class="st"> ms"</span> <span class="op">%</span> (<span class="dv">1000</span> <span class="op">*</span> flow_dict[key][<span class="st">"result"</span>].get(<span class="st">"samp_time"</span>, <span class="dv">0</span>)),</span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>          <span class="st">"</span><span class="sc">{:,}</span><span class="st">"</span>.<span class="bu">format</span>(<span class="bu">sum</span>([np.prod(p.shape) <span class="cf">for</span> p <span class="kw">in</span> jax.tree_util.tree_leaves(flow_dict[key][<span class="st">"model"</span>].state.params)]))] </span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>         <span class="cf">for</span> key <span class="kw">in</span> flow_dict]</span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>display(HTML(tabulate.tabulate(table, tablefmt<span class="op">=</span><span class="st">'html'</span>, headers<span class="op">=</span>[<span class="st">"Model"</span>, <span class="st">"Validation Bpd"</span>, <span class="st">"Test Bpd"</span>, <span class="st">"Inference time"</span>, <span class="st">"Sampling time"</span>, <span class="st">"Num Parameters"</span>])))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<table class="caption-top table table-sm table-striped small" data-quarto-postprocess="true">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th">Model</th>
<th data-quarto-table-cell-role="th">Validation Bpd</th>
<th data-quarto-table-cell-role="th">Test Bpd</th>
<th data-quarto-table-cell-role="th">Inference time</th>
<th data-quarto-table-cell-role="th">Sampling time</th>
<th data-quarto-table-cell-role="th">Num Parameters</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>simple</td>
<td>1.080 bpd</td>
<td>1.078 bpd</td>
<td>8.5 ms</td>
<td>9.0 ms</td>
<td>556,312</td>
</tr>
<tr class="even">
<td>vardeq</td>
<td>1.043 bpd</td>
<td>1.041 bpd</td>
<td>10.9 ms</td>
<td>9.2 ms</td>
<td>628,388</td>
</tr>
<tr class="odd">
<td>multiscale</td>
<td>1.023 bpd</td>
<td>1.021 bpd</td>
<td>7.1 ms</td>
<td>5.3 ms</td>
<td>1,711,818</td>
</tr>
</tbody>
</table>
</div>
</div>
<p>As we have intially expected, using variational dequantization improves upon standard dequantization in terms of bits per dimension. Although the difference with 0.04bpd doesn’t seem impressive first, it is a considerably step for generative models (most state-of-the-art models improve upon previous models in a range of 0.02-0.1bpd on CIFAR with three times as high bpd). While it takes longer to evaluate the probability of an image due to the variational dequantization, which also leads to a longer training time, it does not have an effect on the sampling time. This is because inverting variational dequantization is the same as dequantization: finding the next lower integer.</p>
<p>When we compare the two models to multi-scale architecture, we can see that the bits per dimension score again dropped by about 0.02bpd. Additionally, the inference time and sampling time improved notably despite having more parameters. Thus, we see that the multi-scale flow is not only stronger for density modeling, but also more efficient.</p>
<p>Next, we can test the sampling quality of the models. We should note that the samples for variational dequantization and standard dequantization are very similar, and hence we visualize here only the ones for variational dequantization and the multi-scale model. However, feel free to also test out the <code>"simple"</code> model. The seeds are set to obtain reproducable generations and are not cherry picked.</p>
<div id="cell-61" class="cell" data-execution_count="28">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>sample_rng <span class="op">=</span> random.PRNGKey(<span class="dv">44</span>)</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>samples, _ <span class="op">=</span> flow_dict[<span class="st">"vardeq"</span>][<span class="st">"model"</span>].model_bd.sample(img_shape<span class="op">=</span>[<span class="dv">16</span>,<span class="dv">28</span>,<span class="dv">28</span>,<span class="dv">1</span>], rng<span class="op">=</span>sample_rng)</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>show_imgs(samples)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="NF_image_modeling_files/figure-html/cell-28-output-1.svg" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="cell-62" class="cell" data-execution_count="29">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>sample_rng <span class="op">=</span> random.PRNGKey(<span class="dv">44</span>)</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>samples, _ <span class="op">=</span> flow_dict[<span class="st">"multiscale"</span>][<span class="st">"model"</span>].model_bd.sample(img_shape<span class="op">=</span>[<span class="dv">16</span>,<span class="dv">7</span>,<span class="dv">7</span>,<span class="dv">8</span>], rng<span class="op">=</span>sample_rng)</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>show_imgs(samples)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="NF_image_modeling_files/figure-html/cell-29-output-1.svg" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>From the few samples, we can see a clear difference between the simple and the multi-scale model. The single-scale model has only learned local, small correlations while the multi-scale model was able to learn full, global relations that form digits. This show-cases another benefit of the multi-scale model. In contrast to VAEs, the outputs are sharp as normalizing flows can naturally model complex, multi-modal distributions while VAEs have the independent decoder output noise. Nevertheless, the samples from this flow are far from perfect as not all samples show true digits.</p>
</section>
<section id="interpolation-in-latent-space" class="level3">
<h3 class="anchored" data-anchor-id="interpolation-in-latent-space">Interpolation in latent space</h3>
<p>Another popular test for the smoothness of the latent space of generative models is to interpolate between two training examples. As normalizing flows are strictly invertible, we can guarantee that any image is represented in the latent space. We again compare the variational dequantization model with the multi-scale model below.</p>
<div id="cell-65" class="cell" data-execution_count="30">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> interpolate(model, rng, img1, img2, num_steps<span class="op">=</span><span class="dv">8</span>):</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Inputs:</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a><span class="co">        model - object of ImageFlow class that represents the (trained) flow model</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a><span class="co">        img1, img2 - Image tensors of shape [1, 28, 28]. Images between which should be interpolated.</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a><span class="co">        num_steps - Number of interpolation steps. 8 interpolation steps mean 6 intermediate pictures besides img1 and img2</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>    imgs <span class="op">=</span> np.stack([img1, img2], axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>    z, _, rng <span class="op">=</span> model.encode(imgs, rng)</span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>    alpha <span class="op">=</span> jnp.linspace(<span class="dv">0</span>, <span class="dv">1</span>, num<span class="op">=</span>num_steps).reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a>    interpolations <span class="op">=</span> z[<span class="dv">0</span>:<span class="dv">1</span>] <span class="op">*</span> alpha <span class="op">+</span> z[<span class="dv">1</span>:<span class="dv">2</span>] <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> alpha)</span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a>    interp_imgs, _ <span class="op">=</span> model.sample(interpolations.shape[:<span class="dv">1</span>] <span class="op">+</span> imgs.shape[<span class="dv">1</span>:], rng<span class="op">=</span>rng, z_init<span class="op">=</span>interpolations)</span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a>    show_imgs(interp_imgs, row_size<span class="op">=</span><span class="dv">8</span>)</span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a>exmp_imgs, _ <span class="op">=</span> <span class="bu">next</span>(<span class="bu">iter</span>(train_exmp_loader))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="cell-66" class="cell" data-execution_count="31">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>sample_rng <span class="op">=</span> random.PRNGKey(<span class="dv">42</span>)</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>):</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>    interpolate(flow_dict[<span class="st">"vardeq"</span>][<span class="st">"model"</span>].model_bd, sample_rng, exmp_imgs[<span class="dv">2</span><span class="op">*</span>i], exmp_imgs[<span class="dv">2</span><span class="op">*</span>i<span class="op">+</span><span class="dv">1</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="NF_image_modeling_files/figure-html/cell-31-output-1.svg" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="NF_image_modeling_files/figure-html/cell-31-output-2.svg" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="cell-67" class="cell" data-execution_count="32">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>sample_rng <span class="op">=</span> random.PRNGKey(<span class="dv">42</span>)</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>):</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>    interpolate(flow_dict[<span class="st">"multiscale"</span>][<span class="st">"model"</span>].model_bd, sample_rng, exmp_imgs[<span class="dv">2</span><span class="op">*</span>i], exmp_imgs[<span class="dv">2</span><span class="op">*</span>i<span class="op">+</span><span class="dv">1</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="NF_image_modeling_files/figure-html/cell-32-output-1.svg" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="NF_image_modeling_files/figure-html/cell-32-output-2.svg" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>The interpolations of the multi-scale model result in more realistic digits (first row <span class="math inline">\(7\leftrightarrow 8\leftrightarrow 6\)</span>, second row <span class="math inline">\(9\leftrightarrow 6\)</span>), while the variational dequantization model focuses on local patterns that globally do not form a digit. For the multi-scale model, we actually did not do the “true” interpolation between the two images as we did not consider the variables that were split along the flow (they have been sampled randomly for all samples). However, as we will see in the next experiment, the early variables do not effect the overall image much.</p>
</section>
<section id="visualization-of-latents-in-different-levels-of-multi-scale" class="level3">
<h3 class="anchored" data-anchor-id="visualization-of-latents-in-different-levels-of-multi-scale">Visualization of latents in different levels of multi-scale</h3>
<p>In the following we will focus more on the multi-scale flow. We want to analyse what information is being stored in the variables split at early layers, and what information for the final variables. For this, we sample 8 images where each of them share the same final latent variables, but differ in the other part of the latent variables. Below we visualize three examples of this:</p>
<div id="cell-70" class="cell" data-scrolled="false" data-execution_count="33">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>sample_rng <span class="op">=</span> random.PRNGKey(<span class="dv">46</span>)</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>):</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>    sample_rng, iter_rng <span class="op">=</span> random.split(sample_rng)</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>    z_init <span class="op">=</span> random.normal(sample_rng, [<span class="dv">1</span>,<span class="dv">7</span>,<span class="dv">7</span>,<span class="dv">8</span>])</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>    z_init <span class="op">=</span> z_init.repeat(<span class="dv">8</span>, <span class="dv">0</span>)</span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>    samples, sample_rng <span class="op">=</span> flow_dict[<span class="st">"multiscale"</span>][<span class="st">"model"</span>].model_bd.sample(img_shape<span class="op">=</span>z_init.shape, rng<span class="op">=</span>sample_rng, z_init<span class="op">=</span>z_init)</span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>    show_imgs(samples)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="NF_image_modeling_files/figure-html/cell-33-output-1.svg" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="NF_image_modeling_files/figure-html/cell-33-output-2.svg" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="NF_image_modeling_files/figure-html/cell-33-output-3.svg" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>We see that the early split variables indeed have a smaller effect on the image. Still, small differences can be spot when we look carefully at the borders of the digits. For instance, the hole at the left of the 0 changes for different samples although all of them represent the same coarse structure. This shows that the flow indeed learns to separate the higher-level information in the final variables, while the early split ones contain local noise patterns.</p>
</section>
<section id="visualizing-dequantization" class="level3">
<h3 class="anchored" data-anchor-id="visualizing-dequantization">Visualizing Dequantization</h3>
<p>As a final part of this notebook, we will look at the effect of variational dequantization. We have motivated variational dequantization by the issue of sharp edges/boarders being difficult to model, and a flow would rather prefer smooth, prior-like distributions. To check how what noise distribution <span class="math inline">\(q(u|x)\)</span> the flows in the variational dequantization module have learned, we can plot a histogram of output values from the dequantization and variational dequantization module.</p>
<div id="cell-73" class="cell" data-execution_count="34">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> visualize_dequant_distribution(model, rng, imgs, title):</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Inputs:</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a><span class="co">        model - The flow of which we want to visualize the dequantization distribution</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a><span class="co">        imgs - Example training images of which we want to visualize the dequantization distribution </span></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>    ldj <span class="op">=</span> jnp.zeros(imgs.shape[<span class="dv">0</span>], dtype<span class="op">=</span>jnp.float32)</span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>    dequant_vals <span class="op">=</span> []</span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> tqdm(<span class="bu">range</span>(<span class="dv">8</span>), leave<span class="op">=</span><span class="va">False</span>):</span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a>        d, _, rng <span class="op">=</span> model.flows[<span class="dv">0</span>](imgs, ldj, rng, reverse<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a>        dequant_vals.append(d)</span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a>    dequant_vals <span class="op">=</span> jnp.concatenate(dequant_vals, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a>    dequant_vals <span class="op">=</span> jax.device_get(dequant_vals.reshape(<span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb38-14"><a href="#cb38-14" aria-hidden="true" tabindex="-1"></a>    sns.<span class="bu">set</span>()</span>
<span id="cb38-15"><a href="#cb38-15" aria-hidden="true" tabindex="-1"></a>    plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>,<span class="dv">3</span>))</span>
<span id="cb38-16"><a href="#cb38-16" aria-hidden="true" tabindex="-1"></a>    plt.hist(dequant_vals, bins<span class="op">=</span><span class="dv">256</span>, color<span class="op">=</span>to_rgb(<span class="st">"C0"</span>)<span class="op">+</span>(<span class="fl">0.5</span>,), edgecolor<span class="op">=</span><span class="st">"C0"</span>, density<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb38-17"><a href="#cb38-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> title <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb38-18"><a href="#cb38-18" aria-hidden="true" tabindex="-1"></a>        plt.title(title)</span>
<span id="cb38-19"><a href="#cb38-19" aria-hidden="true" tabindex="-1"></a>    plt.show()</span>
<span id="cb38-20"><a href="#cb38-20" aria-hidden="true" tabindex="-1"></a>    plt.close()</span>
<span id="cb38-21"><a href="#cb38-21" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb38-22"><a href="#cb38-22" aria-hidden="true" tabindex="-1"></a>sample_imgs, _ <span class="op">=</span> <span class="bu">next</span>(<span class="bu">iter</span>(train_exmp_loader))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="cell-74" class="cell" data-execution_count="35">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>sample_rng <span class="op">=</span> random.PRNGKey(<span class="dv">42</span>)</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>visualize_dequant_distribution(flow_dict[<span class="st">"simple"</span>][<span class="st">"model"</span>].model_bd, sample_rng, sample_imgs, title<span class="op">=</span><span class="st">"Dequantization"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"","version_major":2,"version_minor":0,"quarto_mimetype":"application/vnd.jupyter.widget-view+json"}
</script>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="NF_image_modeling_files/figure-html/cell-35-output-2.svg" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="cell-75" class="cell" data-execution_count="36">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>sample_rng <span class="op">=</span> random.PRNGKey(<span class="dv">42</span>)</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>visualize_dequant_distribution(flow_dict[<span class="st">"vardeq"</span>][<span class="st">"model"</span>].model_bd, sample_rng, sample_imgs, title<span class="op">=</span><span class="st">"Variational dequantization"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"","version_major":2,"version_minor":0,"quarto_mimetype":"application/vnd.jupyter.widget-view+json"}
</script>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="NF_image_modeling_files/figure-html/cell-36-output-2.svg" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>The dequantization distribution in the first plot shows that the MNIST images have a strong bias towards 0 (black), and the distribution of them have a sharp border as mentioned before. The variational dequantization module has indeed learned a much smoother distribution with a Gaussian-like curve which can be modeled much better. For the other values, we would need to visualize the distribution <span class="math inline">\(q(u|x)\)</span> on a deeper level, depending on <span class="math inline">\(x\)</span>. However, as all <span class="math inline">\(u\)</span>’s interact and depend on each other, we would need to visualize a distribution in 784 dimensions, which is not that intuitive anymore.</p>
</section>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>In conclusion, we have seen how to implement our own normalizing flow, and what difficulties arise if we want to apply them on images. Dequantization is a crucial step in mapping the discrete images into continuous space to prevent underisable delta-peak solutions. While dequantization creates hypercubes with hard border, variational dequantization allows us to fit a flow much better on the data. This allows us to obtain a lower bits per dimension score, while not affecting the sampling speed. The most common flow element, the coupling layer, is simple to implement, and yet effective. Furthermore, multi-scale architectures help to capture the global image context while allowing us to efficiently scale up the flow. Normalizing flows are an interesting alternative to VAEs as they allow an exact likelihood estimate in continuous space, and we have the guarantee that every possible input <span class="math inline">\(x\)</span> has a corresponding latent vector <span class="math inline">\(z\)</span>. However, even beyond continuous inputs and images, flows can be applied and allow us to exploit the data structure in latent space, as e.g.&nbsp;on graphs for the task of molecule generation [6]. Recent advances in <a href="https://arxiv.org/pdf/1806.07366.pdf">Neural ODEs</a> allow a flow with infinite number of layers, called Continuous Normalizing Flows, whose potential is yet to fully explore. Overall, normalizing flows are an exciting research area which will continue over the next couple of years.</p>
</section>
<section id="references" class="level2">
<h2 class="anchored" data-anchor-id="references">References</h2>
<p>[1] Dinh, L., Sohl-Dickstein, J., and Bengio, S. (2017). “Density estimation using Real NVP,” In: 5th International Conference on Learning Representations, ICLR 2017. <a href="https://arxiv.org/abs/1605.08803">Link</a></p>
<p>[2] Kingma, D. P., and Dhariwal, P. (2018). “Glow: Generative Flow with Invertible 1x1 Convolutions,” In: Advances in Neural Information Processing Systems, vol.&nbsp;31, pp.&nbsp;10215–10224. <a href="http://papers.nips.cc/paper/8224-glow-generative-flow-with-invertible-1x1-convolutions.pdf">Link</a></p>
<p>[3] Ho, J., Chen, X., Srinivas, A., Duan, Y., and Abbeel, P. (2019). “Flow++: Improving Flow-Based Generative Models with Variational Dequantization and Architecture Design,” in Proceedings of the 36th International Conference on Machine Learning, vol.&nbsp;97, pp.&nbsp;2722–2730. <a href="https://arxiv.org/abs/1902.00275">Link</a></p>
<p>[4] Durkan, C., Bekasov, A., Murray, I., and Papamakarios, G. (2019). “Neural Spline Flows,” In: Advances in Neural Information Processing Systems, pp.&nbsp;7509–7520. <a href="http://papers.neurips.cc/paper/8969-neural-spline-flows.pdf">Link</a></p>
<p>[5] Hoogeboom, E., Cohen, T. S., and Tomczak, J. M. (2020). “Learning Discrete Distributions by Dequantization,” arXiv preprint arXiv2001.11235v1. <a href="https://arxiv.org/abs/2001.11235">Link</a></p>
<p>[6] Lippe, P., and Gavves, E. (2021). “Categorical Normalizing Flows via Continuous Transformations,” In: International Conference on Learning Representations, ICLR 2021. <a href="https://openreview.net/pdf?id=-GLNZeVDuik">Link</a></p>
<hr>
<p><a href="https://github.com/phlippe/uvadlc_notebooks/"><img src="https://img.shields.io/static/v1.svg?logo=star&amp;label=⭐&amp;message=Star%20Our%20Repository&amp;color=yellow" class="img-fluid" alt="Star our repository"></a> If you found this tutorial helpful, consider ⭐-ing our repository.<br>
<a href="https://github.com/phlippe/uvadlc_notebooks/issues"><img src="https://img.shields.io/static/v1.svg?logo=star&amp;label=❔&amp;message=Ask%20Questions&amp;color=9cf" class="img-fluid" alt="Ask questions"></a> For any questions, typos, or bugs that you found, please raise an issue on GitHub.</p>
<hr>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/dslnu\.github\.io\/dl_nlp\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>LNU</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>